
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mundipagg/boleto-api/bank/bank.go (77.8%)</option>
				
				<option value="file1">github.com/mundipagg/boleto-api/bank/bb.go (100.0%)</option>
				
				<option value="file2">github.com/mundipagg/boleto-api/bank/bradesco.go (75.0%)</option>
				
				<option value="file3">github.com/mundipagg/boleto-api/bank/caixa.go (100.0%)</option>
				
				<option value="file4">github.com/mundipagg/boleto-api/bank/citibank.go (100.0%)</option>
				
				<option value="file5">github.com/mundipagg/boleto-api/bank/itau.go (100.0%)</option>
				
				<option value="file6">github.com/mundipagg/boleto-api/bank/pefisa.go (0.0%)</option>
				
				<option value="file7">github.com/mundipagg/boleto-api/bank/santander.go (100.0%)</option>
				
				<option value="file8">github.com/mundipagg/boleto-api/bb/bb.go (87.3%)</option>
				
				<option value="file9">github.com/mundipagg/boleto-api/bb/request.go (100.0%)</option>
				
				<option value="file10">github.com/mundipagg/boleto-api/bb/response.go (100.0%)</option>
				
				<option value="file11">github.com/mundipagg/boleto-api/bb/validations.go (72.5%)</option>
				
				<option value="file12">github.com/mundipagg/boleto-api/bradescoNetEmpresa/bradescoNetEmpresa.go (86.3%)</option>
				
				<option value="file13">github.com/mundipagg/boleto-api/bradescoNetEmpresa/request.go (100.0%)</option>
				
				<option value="file14">github.com/mundipagg/boleto-api/bradescoNetEmpresa/response.go (100.0%)</option>
				
				<option value="file15">github.com/mundipagg/boleto-api/bradescoNetEmpresa/validations.go (53.6%)</option>
				
				<option value="file16">github.com/mundipagg/boleto-api/bradescoShopFacil/bradescoShopFacil.go (91.1%)</option>
				
				<option value="file17">github.com/mundipagg/boleto-api/bradescoShopFacil/request.go (100.0%)</option>
				
				<option value="file18">github.com/mundipagg/boleto-api/bradescoShopFacil/response.go (100.0%)</option>
				
				<option value="file19">github.com/mundipagg/boleto-api/bradescoShopFacil/validations.go (62.5%)</option>
				
				<option value="file20">github.com/mundipagg/boleto-api/caixa/caixa.go (86.0%)</option>
				
				<option value="file21">github.com/mundipagg/boleto-api/caixa/request.go (100.0%)</option>
				
				<option value="file22">github.com/mundipagg/boleto-api/caixa/response.go (100.0%)</option>
				
				<option value="file23">github.com/mundipagg/boleto-api/caixa/validations.go (70.3%)</option>
				
				<option value="file24">github.com/mundipagg/boleto-api/citibank/citi.go (85.1%)</option>
				
				<option value="file25">github.com/mundipagg/boleto-api/citibank/request.go (100.0%)</option>
				
				<option value="file26">github.com/mundipagg/boleto-api/citibank/response.go (100.0%)</option>
				
				<option value="file27">github.com/mundipagg/boleto-api/citibank/validations.go (62.5%)</option>
				
				<option value="file28">github.com/mundipagg/boleto-api/itau/itau.go (90.1%)</option>
				
				<option value="file29">github.com/mundipagg/boleto-api/itau/request.go (100.0%)</option>
				
				<option value="file30">github.com/mundipagg/boleto-api/itau/response.go (100.0%)</option>
				
				<option value="file31">github.com/mundipagg/boleto-api/itau/validations.go (72.2%)</option>
				
				<option value="file32">github.com/mundipagg/boleto-api/models/agreement.go (100.0%)</option>
				
				<option value="file33">github.com/mundipagg/boleto-api/models/boleto.go (38.8%)</option>
				
				<option value="file34">github.com/mundipagg/boleto-api/models/credentials.go (0.0%)</option>
				
				<option value="file35">github.com/mundipagg/boleto-api/models/document.go (100.0%)</option>
				
				<option value="file36">github.com/mundipagg/boleto-api/models/errors.go (13.6%)</option>
				
				<option value="file37">github.com/mundipagg/boleto-api/models/fine.go (100.0%)</option>
				
				<option value="file38">github.com/mundipagg/boleto-api/models/title.go (100.0%)</option>
				
				<option value="file39">github.com/mundipagg/boleto-api/models/validator.go (0.0%)</option>
				
				<option value="file40">github.com/mundipagg/boleto-api/parser/parser.go (73.7%)</option>
				
				<option value="file41">github.com/mundipagg/boleto-api/pefisa/pefisa.go (89.0%)</option>
				
				<option value="file42">github.com/mundipagg/boleto-api/pefisa/request.go (100.0%)</option>
				
				<option value="file43">github.com/mundipagg/boleto-api/pefisa/response.go (100.0%)</option>
				
				<option value="file44">github.com/mundipagg/boleto-api/pefisa/validations.go (66.7%)</option>
				
				<option value="file45">github.com/mundipagg/boleto-api/santander/error_messages.go (75.0%)</option>
				
				<option value="file46">github.com/mundipagg/boleto-api/santander/request.go (100.0%)</option>
				
				<option value="file47">github.com/mundipagg/boleto-api/santander/response.go (100.0%)</option>
				
				<option value="file48">github.com/mundipagg/boleto-api/santander/santander.go (88.6%)</option>
				
				<option value="file49">github.com/mundipagg/boleto-api/santander/validations.go (63.6%)</option>
				
				<option value="file50">github.com/mundipagg/boleto-api/tmpl/funcmaps.go (54.9%)</option>
				
				<option value="file51">github.com/mundipagg/boleto-api/tmpl/template.go (0.0%)</option>
				
				<option value="file52">github.com/mundipagg/boleto-api/util/connectors.go (0.0%)</option>
				
				<option value="file53">github.com/mundipagg/boleto-api/util/crypt.go (67.6%)</option>
				
				<option value="file54">github.com/mundipagg/boleto-api/util/error.go (0.0%)</option>
				
				<option value="file55">github.com/mundipagg/boleto-api/util/font.go (0.0%)</option>
				
				<option value="file56">github.com/mundipagg/boleto-api/util/http.go (0.0%)</option>
				
				<option value="file57">github.com/mundipagg/boleto-api/util/json.go (100.0%)</option>
				
				<option value="file58">github.com/mundipagg/boleto-api/util/math.go (0.0%)</option>
				
				<option value="file59">github.com/mundipagg/boleto-api/util/string.go (60.0%)</option>
				
				<option value="file60">github.com/mundipagg/boleto-api/util/time.go (0.0%)</option>
				
				<option value="file61">github.com/mundipagg/boleto-api/util/tls.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bank

import (
        "fmt"

        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/models"
)

//Bank é a interface que vai oferecer os serviços em comum entre os bancos
type Bank interface {
        ProcessBoleto(*models.BoletoRequest) (models.BoletoResponse, error)
        RegisterBoleto(*models.BoletoRequest) (models.BoletoResponse, error)
        ValidateBoleto(*models.BoletoRequest) models.Errors
        GetBankNumber() models.BankNumber
        GetBankNameIntegration() string
        Log() *log.Log
}

//Get retorna estrategia de acordo com o banco ou erro caso o banco não exista
func Get(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        switch boleto.BankNumber </span>{
        case models.BancoDoBrasil:<span class="cov8" title="1">
                return getIntegrationBB(boleto)</span>
        case models.Bradesco:<span class="cov8" title="1">
                return getIntegrationBradesco(boleto)</span>
        case models.Caixa:<span class="cov8" title="1">
                return getIntegrationCaixa(boleto)</span>
        case models.Citibank:<span class="cov8" title="1">
                return getIntegrationCitibank(boleto)</span>
        case models.Santander:<span class="cov8" title="1">
                return getIntegrationSantander(boleto)</span>
        case models.Itau:<span class="cov8" title="1">
                return getIntegrationItau(boleto)</span>
        case models.Pefisa:<span class="cov0" title="0">
                return getIntegrationPefisa(boleto)</span>
        default:<span class="cov0" title="0">
                return nil, models.NewErrorResponse("MPBankNumber", fmt.Sprintf("Banco %d não existe", boleto.BankNumber))</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bank

import (
        "github.com/mundipagg/boleto-api/bb"
        "github.com/mundipagg/boleto-api/models"
)

func getIntegrationBB(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        return bb.New(), nil
}</pre>
		
		<pre class="file" id="file2" style="display: none">package bank

import (
        "fmt"

        "github.com/mundipagg/boleto-api/bradescoNetEmpresa"
        "github.com/mundipagg/boleto-api/bradescoShopFacil"
        "github.com/mundipagg/boleto-api/models"
)

//Get retorna estrategia de acordo com a carteira ou erro caso o banco não exista
func getIntegrationBradesco(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        switch boleto.Agreement.Wallet </span>{
        case 4, 9, 19:<span class="cov8" title="1">
                return bradescoNetEmpresa.New(), nil</span>
        case 25, 26:<span class="cov8" title="1">
                return bradescoShopFacil.New(), nil</span>
        default:<span class="cov0" title="0">
                return nil, models.NewErrorResponse("MPWallet", fmt.Sprintf("Carteira %d não existe", boleto.Agreement.Wallet))</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bank

import (
        "github.com/mundipagg/boleto-api/caixa"
        "github.com/mundipagg/boleto-api/models"
)

func getIntegrationCaixa(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        return caixa.New(), nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package bank

import (
        "github.com/mundipagg/boleto-api/citibank"
        "github.com/mundipagg/boleto-api/models"
)

func getIntegrationCitibank(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        return citibank.New()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package bank

import (
        "github.com/mundipagg/boleto-api/itau"
        "github.com/mundipagg/boleto-api/models"
)

func getIntegrationItau(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        return itau.New(), nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package bank

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/pefisa"
)

func getIntegrationPefisa(boleto models.BoletoRequest) (Bank, error) <span class="cov0" title="0">{
        return pefisa.New(), nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package bank

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/santander"
)

func getIntegrationSantander(boleto models.BoletoRequest) (Bank, error) <span class="cov8" title="1">{
        return santander.New()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package bb

import (
        "errors"
        "strings"
        "sync"

        "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/metrics"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"

        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankBB struct {
        validate *models.Validator
        log      *log.Log
}

//New Cria uma nova instância do objeto que implementa os serviços do Banco do Brasil e configura os validadores que serão utilizados
func New() bankBB <span class="cov8" title="1">{
        b := bankBB{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }
        b.validate.Push(bbValidateAccountAndDigit)
        b.validate.Push(bbValidateAgencyAndDigit)
        b.validate.Push(bbValidateOurNumber)
        b.validate.Push(bbValidateWalletVariation)
        b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(bbValidateTitleInstructions)
        b.validate.Push(bbValidateTitleDocumentNumber)
        b.validate.Push(bbValidateBoletoType)
        return b
}</span>

//Log retorna a referencia do log
func (b bankBB) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b *bankBB) login(boleto *models.BoletoRequest) (string, error) <span class="cov8" title="1">{
        type errorAuth struct {
                Error            string `json:"error"`
                ErrorDescription string `json:"error_description"`
        }

        r := flow.NewFlow()
        url := config.Get().URLBBToken
        from, resp := GetBBAuthLetters()
        bod := r.From("message://?source=inline", boleto, from, tmpl.GetFuncMaps())
        r = r.To("log://?type=request&amp;url="+url, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                bod = bod.To(url, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutToken})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("bb-login-time", duration.Seconds())
        r = r.To("log://?type=response&amp;url="+url, b.log)
        ch := bod.Choice().When(flow.Header("status").IsEqualTo("200")).To("transform://?format=json", resp, `{{.authToken}}`)
        ch = ch.Otherwise().To("unmarshall://?format=json", new(errorAuth))
        result := bod.GetBody()
        switch t := result.(type) </span>{
        case string:<span class="cov8" title="1">
                return t, nil</span>
        case error:<span class="cov0" title="0">
                return "", t</span>
        case *errorAuth:<span class="cov0" title="0">
                return "", errors.New(t.ErrorDescription)</span>
        }
        <span class="cov0" title="0">return "", errors.New("Saída inválida")</span>
}

//ProcessBoleto faz o processamento de registro de boleto
func (b bankBB) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">tok, err := b.login(boleto)
        if err != nil </span><span class="cov0" title="0">{
                return models.BoletoResponse{}, err
        }</span>
        <span class="cov8" title="1">boleto.Authentication.AuthorizationToken = tok
        return b.RegisterBoleto(boleto)</span>
}

func (b bankBB) RegisterBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        r := flow.NewFlow()
        url := config.Get().URLBBRegisterBoleto
        from := getRequest()

        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType(boleto)

        r = r.From("message://?source=inline", boleto, from, tmpl.GetFuncMaps())
        r.To("log://?type=request&amp;url="+url, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                r.To(url, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutRegister})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("bb-register-boleto-time", duration.Seconds())
        r.To("log://?type=response&amp;url="+url, b.log)
        ch := r.Choice()
        ch.When(flow.Header("status").IsEqualTo("200"))
        ch.To("transform://?format=xml", getResponseBB(), getAPIResponse(), tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))
        ch.Otherwise()
        ch.To("log://?type=response&amp;url="+url, b.log).To("apierro://")
        switch t := r.GetBody().(type) </span>{
        case *models.BoletoResponse:<span class="cov8" title="1">
                return *t, nil</span>
        case models.BoletoResponse:<span class="cov0" title="0">
                return t, nil</span>
        case error:<span class="cov0" title="0">
                return models.BoletoResponse{}, t</span>
        default:<span class="cov0" title="0">
                return models.BoletoResponse{}, errors.New("Unexpected Type")</span>
        }

}

func (b bankBB) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

//GetBankNumber retorna o codigo do banco
func (b bankBB) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.BancoDoBrasil
}</span>

func (b bankBB) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "BancoDoBrasil"
}</span>

func bbBoletoTypes() map[string]string <span class="cov8" title="1">{

        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["CH"] = "01" //Cheque
                m["DM"] = "02" //Duplicata Mercantil
                m["DS"] = "04" //Duplicata de serviços
                m["NP"] = "12" //Nota promissória
                m["RC"] = "17" //Recibo
                m["ND"] = "19" //Nota de Débito
        }</span>)

        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "ND", "19"
        }</span>
        <span class="cov8" title="1">btm := bbBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "ND", "19"
        }</span>

        <span class="cov8" title="1">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package bb

/*
@author Philippe Moneda
@date 10/04/2017
Descreve o padrão de mensagem para Boletos do Banco do Brasil
*/
const authBB = `## Content-Type:application/x-www-form-urlencoded
## Cache-Control:no-cache
## Authorization:Basic {{base64 (concat .Authentication.Username ":" .Authentication.Password)}}
grant_type=client_credentials&amp;scope=cobranca.registro-boletos`

const authLetterBBResponse = `
{
        "access_token":"{{authToken}}"        
}
`

//GetBBAuthLetters retorna as cartas de envio e retorno de autencação do BB
func GetBBAuthLetters() (string, string) <span class="cov8" title="1">{
        return authBB, authLetterBBResponse
}</span>

const registerBoleto = `
 ## SOAPACTION:registrarBoleto
 ##        Authorization:Bearer {{.Authentication.AuthorizationToken}}
 ## Content-Type:text/xml; charset=utf-8

 &lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:sch="http://www.tibco.com/schemas/bws_registro_cbr/Recursos/XSD/Schema.xsd"&gt;
 &lt;soapenv:Header/&gt;
 &lt;soapenv:Body&gt;
&lt;sch:requisicao&gt;
 &lt;sch:numeroConvenio&gt;{{.Agreement.AgreementNumber}}&lt;/sch:numeroConvenio&gt;
 &lt;sch:numeroCarteira&gt;17&lt;/sch:numeroCarteira&gt;
 &lt;sch:numeroVariacaoCarteira&gt;{{.Agreement.WalletVariation}}&lt;/sch:numeroVariacaoCarteira&gt;
 &lt;sch:codigoModalidadeTitulo&gt;1&lt;/sch:codigoModalidadeTitulo&gt;
 &lt;sch:dataEmissaoTitulo&gt;{{replace (today | brdate) "/" "."}}&lt;/sch:dataEmissaoTitulo&gt;
 &lt;sch:dataVencimentoTitulo&gt;{{replace (.Title.ExpireDateTime | brdate) "/" "."}}&lt;/sch:dataVencimentoTitulo&gt;
 &lt;sch:valorOriginalTitulo&gt;{{toFloatStr .Title.AmountInCents}}&lt;/sch:valorOriginalTitulo&gt;
 &lt;sch:codigoTipoDesconto&gt;0&lt;/sch:codigoTipoDesconto&gt; 
 &lt;sch:codigoTipoMulta&gt;0&lt;/sch:codigoTipoMulta&gt; 
 &lt;sch:codigoAceiteTitulo&gt;N&lt;/sch:codigoAceiteTitulo&gt;
 &lt;sch:codigoTipoTitulo&gt;{{.Title.BoletoTypeCode}}&lt;/sch:codigoTipoTitulo&gt;
 &lt;sch:textoDescricaoTipoTitulo&gt;&lt;/sch:textoDescricaoTipoTitulo&gt;
 &lt;sch:indicadorPermissaoRecebimentoParcial&gt;N&lt;/sch:indicadorPermissaoRecebimentoParcial&gt;
 &lt;sch:textoNumeroTituloBeneficiario&gt;&lt;/sch:textoNumeroTituloBeneficiario&gt;
 &lt;sch:textoNumeroTituloCliente&gt;000{{padLeft (toString .Agreement.AgreementNumber) "0" 7}}{{padLeft (toString .Title.OurNumber) "0" 10}}&lt;/sch:textoNumeroTituloCliente&gt;
 &lt;sch:textoMensagemBloquetoOcorrencia&gt;Pagamento disponível até a data de vencimento&lt;/sch:textoMensagemBloquetoOcorrencia&gt;
 &lt;sch:codigoTipoInscricaoPagador&gt;{{docType .Buyer.Document}}&lt;/sch:codigoTipoInscricaoPagador&gt;
 &lt;sch:numeroInscricaoPagador&gt;{{clearString (truncate .Buyer.Document.Number 15)}}&lt;/sch:numeroInscricaoPagador&gt;
 &lt;sch:nomePagador&gt;{{clearString (truncate .Buyer.Name 60)}}&lt;/sch:nomePagador&gt;
 &lt;sch:textoEnderecoPagador&gt;{{clearString (truncate .Buyer.Address.Street 60)}}&lt;/sch:textoEnderecoPagador&gt;
 &lt;sch:numeroCepPagador&gt;{{extractNumbers .Buyer.Address.ZipCode}}&lt;/sch:numeroCepPagador&gt;
 &lt;sch:nomeMunicipioPagador&gt;{{clearString (truncate .Buyer.Address.City 20)}}&lt;/sch:nomeMunicipioPagador&gt;
 &lt;sch:nomeBairroPagador&gt;{{clearString (truncate .Buyer.Address.District 20)}}&lt;/sch:nomeBairroPagador&gt;
 &lt;sch:siglaUfPagador&gt;{{clearString (truncate .Buyer.Address.StateCode 2)}}&lt;/sch:siglaUfPagador&gt; 
 &lt;sch:codigoChaveUsuario&gt;1&lt;/sch:codigoChaveUsuario&gt;
 &lt;sch:codigoTipoCanalSolicitacao&gt;5&lt;/sch:codigoTipoCanalSolicitacao&gt;
 &lt;/sch:requisicao&gt;
 &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
 `

//getRequest retorna o template do Banco do Brasil
func getRequest() string <span class="cov8" title="1">{
        return registerBoleto
}</span>

const registerBoletoBBResponse = `

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&gt;
&lt;SOAP-ENV:Body&gt;
        &lt;ns0:resposta xmlns:ns0="http://www.tibco.com/schemas/bws_registro_cbr/Recursos/XSD/Schema.xsd"&gt;
                &lt;ns0:siglaSistemaMensagem /&gt;
                &lt;ns0:codigoRetornoPrograma&gt;{{returnCode}}&lt;/ns0:codigoRetornoPrograma&gt;
                &lt;ns0:nomeProgramaErro&gt;{{errorCode}}&lt;/ns0:nomeProgramaErro&gt;
                &lt;ns0:textoMensagemErro&gt;{{errorMessage}}&lt;/ns0:textoMensagemErro&gt;
                &lt;ns0:linhaDigitavel&gt;{{digitableLine}}&lt;/ns0:linhaDigitavel&gt;
                &lt;ns0:codigoBarraNumerico&gt;{{barcodeNumber}}&lt;/ns0:codigoBarraNumerico&gt;                                
        &lt;/ns0:resposta&gt;
&lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;

`

func getResponseBB() string <span class="cov8" title="1">{
        return registerBoletoBBResponse
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package bb

const registerBoletoResponseBB = `{
    {{if (hasErrorTags . "errorCode")}}
        "Errors": [
            {                    
                "Code": "{{trim .errorCode}}",
                "Message": "{{trim .errorMessage}}"
            }
        ]
    {{else}}
        "DigitableLine": "{{fmtDigitableLine (trim .digitableLine)}}",
        "BarCodeNumber": "{{trim .barcodeNumber}}"
    {{end}}
}
`

func getAPIResponse() string <span class="cov8" title="1">{
        return registerBoletoResponseBB
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package bb

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

var bb bankBB

func bbAgencyDigitCalculator(agency string) string <span class="cov8" title="1">{
        multiplier := []int{5, 4, 3, 2}
        return validations.ModElevenCalculator(agency, multiplier)
}</span>

func bbAccountDigitCalculator(agency, account string) string <span class="cov8" title="1">{
        multiplier := []int{9, 8, 7, 6, 5, 4, 3, 2}
        return validations.ModElevenCalculator(account, multiplier)
}</span>

func bbValidateAgencyAndDigit(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAgencyValid()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">t.Agreement.CalculateAgencyDigit(bbAgencyDigitCalculator)
                return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bbValidateAccountAndDigit(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAccountValid(8)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">t.Agreement.CalculateAccountDigit(bbAccountDigitCalculator)
                return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bbValidateOurNumber(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Title.OurNumber &gt; 9999999999 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MPOurNumber", "Nosso número inválido")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bbValidateWalletVariation(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.WalletVariation &lt; 1 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MPWalletVariation", "Variação da carteira inválida")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bbValidateTitleInstructions(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                return t.Title.ValidateInstructionsLength(220)</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bbValidateTitleDocumentNumber(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                return t.Title.ValidateDocumentNumber()</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bbValidateBoletoType(b interface{}) error <span class="cov8" title="1">{
        bt := bbBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package bradescoNetEmpresa

import (
        "sync"
        "errors"
        "fmt"
        "html"
        "strings"
        "time"

        "github.com/mundipagg/boleto-api/metrics"

        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"

        "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankBradescoNetEmpresa struct {
        validate *models.Validator
        log      *log.Log
}

type barcode struct {
        bankCode      string
        currencyCode  string
        dateDueFactor string
        value         string
        agency        string
        wallet        string
        ourNumber     string
        account       string
        zero          string
}

func New() bankBradescoNetEmpresa <span class="cov8" title="1">{
        b := bankBradescoNetEmpresa{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }
        b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)

        b.validate.Push(bradescoNetEmpresaValidateAgency)
        b.validate.Push(bradescoNetEmpresaValidateAccount)
        b.validate.Push(bradescoNetEmpresaValidateWallet)
        b.validate.Push(bradescoNetEmpresaBoletoTypeValidate)
        return b
}</span>

func (b bankBradescoNetEmpresa) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b bankBradescoNetEmpresa) RegisterBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{

        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType(boleto)
        r := flow.NewFlow()
        serviceURL := config.Get().URLBradescoNetEmpresa
        xmlResponse := getResponseBradescoNetEmpresaXml()
        jsonReponse := getResponseBradescoNetEmpresaJson()
        from := getResponseBradescoNetEmpresa()
        to := getAPIResponseBradescoNetEmpresa()

        bod := r.From("message://?source=inline", boleto, getRequestBradescoNetEmpresa(), tmpl.GetFuncMaps())
        bod.To("log://?type=request&amp;url="+serviceURL, b.log)

        err := signRequest(bod)
        if err != nil </span><span class="cov0" title="0">{
                return models.BoletoResponse{}, err
        }</span>

        <span class="cov8" title="1">duration := util.Duration(func() </span><span class="cov8" title="1">{
                bod.To(serviceURL, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutDefault})
        }</span>)

        <span class="cov8" title="1">metrics.PushTimingMetric("bradesco-netempresa-register-boleto-online", duration.Seconds())
        bod.To("log://?type=response&amp;url="+serviceURL, b.log)

        bod.To("transform://?format=xml", xmlResponse, jsonReponse)
        bodyTransform := fmt.Sprintf("%v", bod.GetBody())
        bodyJson := html.UnescapeString(bodyTransform)
        bod.To("set://?prop=body", bodyJson)

        ch := bod.Choice()

        if header := bod.GetHeader(); header["status"] == "200" </span><span class="cov8" title="1">{
                ch.When(flow.Header("status").IsEqualTo("200"))
        }</span> else<span class="cov8" title="1"> {
                ch.When(flow.Header("status").IsEqualTo("500"))
        }</span>

        <span class="cov8" title="1">ch.To("transform://?format=json", from, to, tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))
        ch.Otherwise()
        ch.To("log://?type=response&amp;url="+serviceURL, b.log).To("apierro://")

        switch t := bod.GetBody().(type) </span>{
        case *models.BoletoResponse:<span class="cov8" title="1">
                if !t.HasErrors() </span><span class="cov8" title="1">{
                        t.BarCodeNumber = getBarcode(*boleto).toString()
                }</span>
                <span class="cov8" title="1">return *t, nil</span>
        case error:<span class="cov0" title="0">
                return models.BoletoResponse{}, t</span>
        }
        <span class="cov0" title="0">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}

func (b bankBradescoNetEmpresa) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">return b.RegisterBoleto(boleto)</span>
}

func (b bankBradescoNetEmpresa) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

func (b bankBradescoNetEmpresa) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Bradesco
}</span>

func (b bankBradescoNetEmpresa) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "BradescoNetEmpresa"
}</span>

func signRequest(bod *flow.Flow) error <span class="cov8" title="1">{

        if !config.Get().MockMode </span><span class="cov0" title="0">{
                bodyToSign := fmt.Sprintf("%v", bod.GetBody())
                signedRequest, err := util.SignRequest(bodyToSign)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">bod.To("set://?prop=body", signedRequest)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getBarcode(boleto models.BoletoRequest) (bc barcode) <span class="cov8" title="1">{
        bc.bankCode = fmt.Sprintf("%d", models.Bradesco)
        bc.currencyCode = fmt.Sprintf("%d", models.Real)
        bc.account = fmt.Sprintf("%07s", boleto.Agreement.Account)
        bc.agency = fmt.Sprintf("%04s", boleto.Agreement.Agency)
        bc.dateDueFactor, _ = dateDueFactor(boleto.Title.ExpireDateTime)
        bc.ourNumber = fmt.Sprintf("%011d", boleto.Title.OurNumber)
        bc.value = fmt.Sprintf("%010d", boleto.Title.AmountInCents)
        bc.wallet = fmt.Sprintf("%02d", boleto.Agreement.Wallet)
        bc.zero = "0"
        return
}</span>

func (bc barcode) toString() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s%s%s%s%s%s%s%s%s", bc.bankCode, bc.currencyCode, bc.calcCheckDigit(), bc.dateDueFactor, bc.value, bc.agency, bc.wallet, bc.ourNumber, bc.account, bc.zero)
}</span>

func (bc barcode) calcCheckDigit() string <span class="cov8" title="1">{
        prevCode := fmt.Sprintf("%s%s%s%s%s%s%s%s%s", bc.bankCode, bc.currencyCode, bc.dateDueFactor, bc.value, bc.agency, bc.wallet, bc.ourNumber, bc.account, bc.zero)
        return util.BarcodeDv(prevCode)
}</span>

func dateDueFactor(dateDue time.Time) (string, error) <span class="cov8" title="1">{
        var dateDueFixed = time.Date(1997, 10, 7, 0, 0, 0, 0, time.UTC)
        dif := dateDue.Sub(dateDueFixed)
        factor := int(dif.Hours() / 24)
        if factor &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.New("DateDue must be in the future")
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%04d", factor), nil</span>
}

func bradescoNetEmpresaBoletoTypes() map[string]string <span class="cov8" title="1">{

        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["CH"] = "01"  //Cheque
                m["DM"] = "02"  //Duplicata Mercantil
                m["DS"] = "04"  //Duplicata de serviços
                m["NP"] = "12"  //Nota promissória
                m["RC"] = "17"  //Recibo
                m["OUT"] = "99" //Outros
        }</span>)

        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "DM", "02"
        }</span>
        <span class="cov8" title="1">btm := bradescoNetEmpresaBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "DM", "02"
        }</span>

        <span class="cov8" title="1">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package bradescoNetEmpresa

const registerBradescoNetEmpresa = `
## Content-Type:application/json
{
    {{if (eq .Recipient.Document.Type "CNPJ")}}
        "nuCPFCNPJ": "{{splitValues (extractNumbers .Recipient.Document.Number) 0 8}}",    
    {{else}}
         "nuCPFCNPJ": "{{splitValues (extractNumbers .Recipient.Document.Number) 0 9}}",        
        {{end}}
    
        {{if (eq .Recipient.Document.Type "CNPJ")}}
        "filialCPFCNPJ": "{{splitValues (extractNumbers .Recipient.Document.Number) 8 12}}",    
    {{else}}
            "filialCPFCNPJ": "0",        
        {{end}}
        
    {{if (eq .Recipient.Document.Type "CNPJ")}}
        "ctrlCPFCNPJ": "{{splitValues (extractNumbers .Recipient.Document.Number) 12 14}}",
    {{else}}
        "ctrlCPFCNPJ": "{{splitValues (extractNumbers .Recipient.Document.Number) 9 11}}",        
    {{end}}        
    "cdTipoAcesso": "2",
    "clubBanco": "2269651",
    "cdTipoContrato": "48",    
    "idProduto": "{{padLeft (toString16 .Agreement.Wallet) "0" 2}}",
    "nuNegociacao": "{{.Agreement.Agency}}0000000{{.Agreement.Account}}",
    "cdBanco": "237",    
    "tpRegistro": "1",    
    "nuTitulo": "{{.Title.OurNumber}}",
    "nuCliente": "{{.Title.DocumentNumber}}",
        "dtEmissaoTitulo": "{{brDateDelimiterTime .Title.CreateDate "."}}",
    "dtVencimentoTitulo": "{{brDateDelimiter .Title.ExpireDate "."}}",
    "tpVencimento": "0",
    "vlNominalTitulo": "{{.Title.AmountInCents}}",
    "cdEspecieTitulo": "{{ .Title.BoletoTypeCode}}",
    "nomePagador": "{{truncate .Buyer.Name 70}}",
    "logradouroPagador": "{{truncate .Buyer.Address.Street 40}}",
    "nuLogradouroPagador": "{{truncate .Buyer.Address.Number 10}}",
    "complementoLogradouroPagador": "{{truncate .Buyer.Address.Complement 15}}",
        {{ $length := len (extractNumbers .Buyer.Address.ZipCode)}}
        {{ $zipCode := (extractNumbers .Buyer.Address.ZipCode)}}
        {{ if ge $length 5}}
                "cepPagador": "{{splitValues $zipCode 0 5}}",
        {{ end }}

        {{ if ge $length 8}}
                "complementoCepPagador": "{{splitValues $zipCode 5 8}}",
        {{ end }}

    "bairroPagador": "{{truncate .Buyer.Address.District 40}}",
    "municipioPagador": "{{truncate .Buyer.Address.City 30}}",
    "ufPagador": "{{truncate .Buyer.Address.StateCode 2}}",
    {{if (eq .Buyer.Document.Type "CPF")}}
            "cdIndCpfcnpjPagador": "1",
    {{else}}
        "cdIndCpfcnpjPagador": "2",
    {{end}}
    "nuCpfcnpjPagador": "{{extractNumbers .Buyer.Document.Number}}",
    "endEletronicoPagador": "{{truncate .Buyer.Email 70}}",    
}
`

const reponseBradescoNetEmpresaXml = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;soapenv:Body&gt;
        &lt;ns2:registrarTituloResponse xmlns:ns2="http://ws.registrotitulo.ibpj.web.bradesco.com.br/"&gt;
                        &lt;return&gt;{{contentJson}}&lt;/return&gt;
        &lt;/ns2:registrarTituloResponse&gt;
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

const responseBradescoNetEmpresaJson = `{{.contentJson}}`

const reponseBradescoNetEmpresa = `
{
    "cdErro": "{{returnCode}}",
    "msgErro": "{{returnMessage}}",    
    "linhaDigitavel": "{{digitableLine}}"
}
`

func getRequestBradescoNetEmpresa() string <span class="cov8" title="1">{
        return registerBradescoNetEmpresa
}</span>

func getResponseBradescoNetEmpresaXml() string <span class="cov8" title="1">{
        return reponseBradescoNetEmpresaXml
}</span>

func getResponseBradescoNetEmpresaJson() string <span class="cov8" title="1">{
        return responseBradescoNetEmpresaJson
}</span>

func getResponseBradescoNetEmpresa() string <span class="cov8" title="1">{
        return reponseBradescoNetEmpresa
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package bradescoNetEmpresa

var apiResponse = `
{
        {{if eq .returnCode "0"}}
           "DigitableLine": "{{.digitableLine}}",
           "BarCodeNumber": "{{.barcodeNumber}}"
    {{else}}
     "Errors": [
                {
                        "Code": "{{.returnCode}}",
                        "Message": "{{.returnMessage}}"
                }
        ]
    {{end}}
}
`

func getAPIResponseBradescoNetEmpresa() string <span class="cov8" title="1">{
        return apiResponse
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package bradescoNetEmpresa

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func bradescoNetEmpresaValidateAgency(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAgencyValid()
                if err != nil </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", err.Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoNetEmpresaValidateAccount(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAccountValid(7)
                if err != nil </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", err.Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoNetEmpresaValidateWallet(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.Wallet != 4 &amp;&amp; t.Agreement.Wallet != 9 &amp;&amp; t.Agreement.Wallet != 19 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "a carteira deve ser 4, 9 ou 19 para o bradescoNetEmpresa")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoNetEmpresaValidateAgreement(b interface{}) error <span class="cov0" title="0">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov0" title="0">
                if t.Agreement.AgreementNumber == 0 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "o código do contrato deve ser preenchido")
                }</span>
                <span class="cov0" title="0">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoNetEmpresaBoletoTypeValidate(b interface{}) error <span class="cov8" title="1">{
        bt := bradescoNetEmpresaBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package bradescoShopFacil

import (
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/mundipagg/boleto-api/metrics"

        "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankBradescoShopFacil struct {
        validate *models.Validator
        log      *log.Log
}

//barcode struct for bradescoShopFacil
type barcode struct {
        bankCode      string
        currencyCode  string
        dateDueFactor string
        value         string
        agency        string
        wallet        string
        ourNumber     string
        account       string
        zero          string
}

//New creates a new BradescoShopFacil instance
func New() bankBradescoShopFacil <span class="cov8" title="1">{
        b := bankBradescoShopFacil{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }
        b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(bradescoShopFacilValidateAgency)
        b.validate.Push(bradescoShopFacilValidateAccount)
        b.validate.Push(bradescoShopFacilValidateWallet)
        b.validate.Push(bradescoShopFacilValidateAuth)
        b.validate.Push(bradescoShopFacilValidateAgreement)
        b.validate.Push(bradescoShopFacilBoletoTypeValidate)
        return b
}</span>

//Log retorna a referencia do log
func (b bankBradescoShopFacil) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b bankBradescoShopFacil) RegisterBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType(boleto)
        r := flow.NewFlow()
        serviceURL := config.Get().URLBradescoShopFacil
        from := getResponseBradescoShopFacil()
        to := getAPIResponseBradescoShopFacil()
        bod := r.From("message://?source=inline", boleto, getRequestBradescoShopFacil(), tmpl.GetFuncMaps())
        bod.To("log://?type=request&amp;url="+serviceURL, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                bod.To(serviceURL, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutDefault})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("bradesco-shopfacil-register-boleto-online", duration.Seconds())
        bod.To("log://?type=response&amp;url="+serviceURL, b.log)
        ch := bod.Choice()
        ch.When(flow.Header("status").IsEqualTo("201"))
        ch.To("transform://?format=json", from, to, tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))
        ch.When(flow.Header("status").IsEqualTo("200"))
        ch.To("transform://?format=json", from, to, tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))
        ch.Otherwise()
        ch.To("log://?type=response&amp;url="+serviceURL, b.log).To("apierro://")
        switch t := bod.GetBody().(type) </span>{
        case *models.BoletoResponse:<span class="cov8" title="1">
                if !t.HasErrors() </span><span class="cov8" title="1">{
                        t.BarCodeNumber = getBarcode(*boleto).toString()
                }</span>
                <span class="cov8" title="1">return *t, nil</span>
        case error:<span class="cov0" title="0">
                return models.BoletoResponse{}, t</span>
        }
        <span class="cov0" title="0">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}

func (b bankBradescoShopFacil) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">return b.RegisterBoleto(boleto)</span>
}

func (b bankBradescoShopFacil) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

func (b bankBradescoShopFacil) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Bradesco
}</span>

func getBarcode(boleto models.BoletoRequest) (bc barcode) <span class="cov8" title="1">{
        bc.bankCode = fmt.Sprintf("%d", models.Bradesco)
        bc.currencyCode = fmt.Sprintf("%d", models.Real)
        bc.account = fmt.Sprintf("%07s", boleto.Agreement.Account)
        bc.agency = fmt.Sprintf("%04s", boleto.Agreement.Agency)
        bc.dateDueFactor, _ = dateDueFactor(boleto.Title.ExpireDateTime)
        bc.ourNumber = fmt.Sprintf("%011d", boleto.Title.OurNumber)
        bc.value = fmt.Sprintf("%010d", boleto.Title.AmountInCents)
        bc.wallet = fmt.Sprintf("%02d", boleto.Agreement.Wallet)
        bc.zero = "0"
        return
}</span>

func (bc barcode) toString() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s%s%s%s%s%s%s%s%s", bc.bankCode, bc.currencyCode, bc.calcCheckDigit(), bc.dateDueFactor, bc.value, bc.agency, bc.wallet, bc.ourNumber, bc.account, bc.zero)
}</span>

func (bc barcode) calcCheckDigit() string <span class="cov8" title="1">{
        prevCode := fmt.Sprintf("%s%s%s%s%s%s%s%s%s", bc.bankCode, bc.currencyCode, bc.dateDueFactor, bc.value, bc.agency, bc.wallet, bc.ourNumber, bc.account, bc.zero)
        return util.BarcodeDv(prevCode)
}</span>

func dateDueFactor(dateDue time.Time) (string, error) <span class="cov8" title="1">{
        var dateDueFixed = time.Date(1997, 10, 7, 0, 0, 0, 0, time.UTC)
        dif := dateDue.Sub(dateDueFixed)
        factor := int(dif.Hours() / 24)
        if factor &lt;= 0 </span><span class="cov0" title="0">{
                return "", errors.New("DateDue must be in the future")
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%04d", factor), nil</span>
}

func (b bankBradescoShopFacil) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "BradescoShopFacil"
}</span>

func bradescoShopFacilBoletoTypes() map[string]string <span class="cov8" title="1">{

        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["DM"] = "01"  //Duplicata Mercantil
                m["NP"] = "02"  //Nota promissória
                m["RC"] = "05"  //Recibo
                m["DS"] = "12"  //Duplicata de serviço
                m["OUT"] = "99" //Outros
        }</span>)
        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "DM", "01"
        }</span>
        <span class="cov8" title="1">btm := bradescoShopFacilBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "DM", "01"
        }</span>

        <span class="cov8" title="1">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>

}
</pre>
		
		<pre class="file" id="file17" style="display: none">package bradescoShopFacil

const registerBradescoShopFacil = `
## Content-Type:application/json
## Authorization:Basic {{base64 (concat .Authentication.Username ":" .Authentication.Password)}}
{
    "merchant_id": "{{.Authentication.Username}}",
    "meio_pagamento": "300",
    "pedido": {
        "numero": "{{escapeStringOnJson .Title.DocumentNumber}}",
        "valor": {{.Title.AmountInCents}},
        "descricao": ""
    },
    "comprador": {
        "nome": "{{escapeStringOnJson .Buyer.Name}}",
        "documento": "{{escapeStringOnJson .Buyer.Document.Number}}",
        "endereco": {
            "cep": "{{extractNumbers .Buyer.Address.ZipCode}}",
            "logradouro": "{{escapeStringOnJson .Buyer.Address.Street}}",
            "numero": "{{escapeStringOnJson .Buyer.Address.Number}}",
            "complemento": "{{escapeStringOnJson .Buyer.Address.Complement}}",
            "bairro": "{{escapeStringOnJson .Buyer.Address.District}}",
            "cidade": "{{escapeStringOnJson .Buyer.Address.City}}",
            "uf": "{{escapeStringOnJson .Buyer.Address.StateCode}}"
        },
        "ip": "",
        "user_agent": ""
    },
    "boleto": {
        "beneficiario": "{{escapeStringOnJson .Recipient.Name}}",
        "carteira": "{{.Agreement.Wallet}}",
        "nosso_numero": "{{padLeft (toString .Title.OurNumber) "0" 11}}",
        "data_emissao": "{{enDate today "-"}}",
        "data_vencimento": "{{enDate .Title.ExpireDateTime "-"}}",
        "valor_titulo": {{.Title.AmountInCents}},
        "url_logotipo": "",
        "mensagem_cabecalho": "",
        "tipo_renderizacao": "1",
        "instrucoes": {
            "instrucao_linha_1": "{{escapeStringOnJson .Title.Instructions}}"
        },
        "registro": {
            "agencia_pagador": "",
            "razao_conta_pagador": "",
            "conta_pagador": "",
            "controle_participante": "",
            "aplicar_multa": false,
            "valor_percentual_multa": 0,
            "valor_desconto_bonificacao": 0,
            "debito_automatico": false,
            "rateio_credito": false,
            "endereco_debito_automatico": "2",
            "tipo_ocorrencia": "02",
            "especie_titulo": "{{ .Title.BoletoTypeCode}}",
            "primeira_instrucao": "00",
            "segunda_instrucao": "00",
            "valor_juros_mora": 0,
            "data_limite_concessao_desconto": null,
            "valor_desconto": 0,
            "valor_iof": 0,
            "valor_abatimento": 0,
            {{if (eq .Buyer.Document.Type "CPF")}}
                    "tipo_inscricao_pagador": "01",
                        {{else}}
                    "tipo_inscricao_pagador": "02",
                        {{end}}
            "sequencia_registro": ""
        }
    },
    "token_request_confirmacao_pagamento": ""
}
`

const responseBradescoShopFacil = `
{
    "boleto": {
        "linha_digitavel": "{{digitableLine}}",
        "url_acesso": "{{url}}"
    },
    "status": {
        "codigo": "{{returnCode}}",
        "mensagem": "{{returnMessage}}"
    }
}
`

func getRequestBradescoShopFacil() string <span class="cov8" title="1">{
        return registerBradescoShopFacil
}</span>

func getResponseBradescoShopFacil() string <span class="cov8" title="1">{
        return responseBradescoShopFacil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package bradescoShopFacil

var apiResponse = `
{
        {{if or (eq .returnCode "0") (eq .returnCode "93005999")}}
       "DigitableLine": "{{fmtDigitableLine (trim .digitableLine)}}",
                "Links": [{
                        "href":"{{.url}}",
                        "rel": "pdf",
                        "method":"GET"
                }]
    {{else}}
     "Errors": [
                {
                        "Code": "{{.returnCode}}",
                        "Message": "{{.returnMessage}}"
                }
        ]
    {{end}}
}
`

func getAPIResponseBradescoShopFacil() string <span class="cov8" title="1">{
        return apiResponse
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package bradescoShopFacil

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func bradescoShopFacilValidateAgency(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAgencyValid()
                if err != nil </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", err.Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoShopFacilValidateAccount(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.Account == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "a conta deve ser preenchida")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoShopFacilValidateWallet(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.Wallet != 25 &amp;&amp; t.Agreement.Wallet != 26 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "a carteira deve ser 25 ou 26 para o BradescoShopFacil")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoShopFacilValidateAuth(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Authentication.Username == "" || t.Authentication.Password == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "o nome de usuário e senha devem ser preenchidos")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoShopFacilValidateAgreement(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.AgreementNumber == 0 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "o código do contrato deve ser preenchido")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func bradescoShopFacilBoletoTypeValidate(b interface{}) error <span class="cov8" title="1">{
        bt := bradescoShopFacilBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package caixa

import (
        "fmt"
        "strings"
        "sync"

        "github.com/mundipagg/boleto-api/metrics"

        "github.com/PMoneda/flow"

        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankCaixa struct {
        validate *models.Validator
        log      *log.Log
}

func New() bankCaixa <span class="cov8" title="1">{
        b := bankCaixa{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }
        b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(caixaValidateAgency)
        b.validate.Push(validadeOurNumber)
        b.validate.Push(caixaValidateBoletoType)
        return b
}</span>

//Log retorna a referencia do log
func (b bankCaixa) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>
func (b bankCaixa) RegisterBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{

        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType(boleto)

        r := flow.NewFlow()
        urlCaixa := config.Get().URLCaixaRegisterBoleto
        from := getResponseCaixa()
        to := getAPIResponseCaixa()

        bod := r.From("message://?source=inline", boleto, getRequestCaixa(), tmpl.GetFuncMaps())
        bod = bod.To("log://?type=request&amp;url="+urlCaixa, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                bod = bod.To(urlCaixa, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutDefault})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("caixa-register-time", duration.Seconds())
        bod = bod.To("log://?type=response&amp;url="+urlCaixa, b.log)
        ch := bod.Choice()
        ch = ch.When(flow.Header("status").IsEqualTo("200"))
        ch = ch.To("transform://?format=xml", from, to, tmpl.GetFuncMaps())
        ch = ch.Otherwise()
        ch = ch.To("log://?type=response&amp;url="+urlCaixa, b.log).To("apierro://")

        switch t := bod.GetBody().(type) </span>{
        case string:<span class="cov8" title="1">
                response := util.ParseJSON(t, new(models.BoletoResponse)).(*models.BoletoResponse)
                return *response, nil</span>
        case models.BoletoResponse:<span class="cov0" title="0">
                return t, nil</span>
        }
        <span class="cov0" title="0">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}
func (b bankCaixa) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>

        <span class="cov8" title="1">boleto.Title.OurNumber = b.FormatOurNumber(boleto.Title.OurNumber)

        checkSum := b.getCheckSumCode(*boleto)

        boleto.Authentication.AuthorizationToken = b.getAuthToken(checkSum)
        return b.RegisterBoleto(boleto)</span>
}

func (b bankCaixa) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

func (b bankCaixa) FormatOurNumber(ourNumber uint) uint <span class="cov8" title="1">{

        if ourNumber != 0 </span><span class="cov0" title="0">{
                ourNumberFormatted := 14000000000000000 + ourNumber

                return ourNumberFormatted
        }</span>

        <span class="cov8" title="1">return ourNumber</span>
}

//getCheckSumCode Código do Cedente (7 posições) + Nosso Número (17 posições) + Data de Vencimento (DDMMAAAA) + Valor (15 posições) + CPF/CNPJ (14 Posições)
func (b bankCaixa) getCheckSumCode(boleto models.BoletoRequest) string <span class="cov8" title="1">{

        return fmt.Sprintf("%07d%017d%s%015d%014s",
                boleto.Agreement.AgreementNumber,
                boleto.Title.OurNumber,
                boleto.Title.ExpireDateTime.Format("02012006"),
                boleto.Title.AmountInCents,
                boleto.Recipient.Document.Number)
}</span>

func (b bankCaixa) getAuthToken(info string) string <span class="cov8" title="1">{
        return util.Sha256(info, "base64")
}</span>

//GetBankNumber retorna o codigo do banco
func (b bankCaixa) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Caixa
}</span>

func (b bankCaixa) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "Caixa"
}</span>

func caixaBoletoTypes() map[string]string <span class="cov8" title="1">{
        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["OUT"] = "99" //Duplicata Mercantil p/ Indicação
        }</span>)
        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "OUT", "99"
        }</span>
        <span class="cov8" title="1">btm := caixaBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "OUT", "99"
        }</span>

        <span class="cov0" title="0">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package caixa

const responseCaixa = `
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;soapenv:Body&gt;
        &lt;manutencaocobrancabancaria:SERVICO_SAIDA xmlns:manutencaocobrancabancaria="http://caixa.gov.br/sibar/manutencao_cobranca_bancaria/boleto/externo" xmlns:sibar_base="http://caixa.gov.br/sibar"&gt;
            &lt;sibar_base:HEADER&gt;
                &lt;OPERACAO&gt;{{operation}}&lt;/OPERACAO&gt;
                &lt;DATA_HORA&gt;{{datetime}}&lt;/DATA_HORA&gt;
            &lt;/sibar_base:HEADER&gt;
            &lt;DADOS&gt;                
                &lt;CONTROLE_NEGOCIAL&gt;
                    &lt;ORIGEM_RETORNO&gt;SIGCB&lt;/ORIGEM_RETORNO&gt;
                    &lt;COD_RETORNO&gt;{{returnCode}}&lt;/COD_RETORNO&gt;
                    &lt;MENSAGENS&gt;
                        &lt;RETORNO&gt;{{returnMessage}}&lt;/RETORNO&gt;
                    &lt;/MENSAGENS&gt;
                &lt;/CONTROLE_NEGOCIAL&gt;
                &lt;INCLUI_BOLETO&gt;
                    &lt;EXCECAO&gt;{{exception}}&lt;/EXCECAO&gt;
                    &lt;CODIGO_BARRAS&gt;{{barcodeNumber}}&lt;/CODIGO_BARRAS&gt;
                    &lt;LINHA_DIGITAVEL&gt;{{digitableLine}}&lt;/LINHA_DIGITAVEL&gt;
                    &lt;NOSSO_NUMERO&gt;{{ourNumber}}&lt;/NOSSO_NUMERO&gt;
                    &lt;URL&gt;{{url}}&lt;/URL&gt;
                &lt;/INCLUI_BOLETO&gt;
            &lt;/DADOS&gt;
        &lt;/manutencaocobrancabancaria:SERVICO_SAIDA&gt;
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

const incluiBoleto = `

## SOAPAction:IncluiBoleto
## Content-Type:text/xml

&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ext="http://caixa.gov.br/sibar/manutencao_cobranca_bancaria/boleto/externo" xmlns:sib="http://caixa.gov.br/sibar"&gt;
&lt;soapenv:Body&gt;
&lt;ext:SERVICO_ENTRADA &gt;
         &lt;sib:HEADER&gt;
            &lt;VERSAO&gt;1.0&lt;/VERSAO&gt;
            &lt;AUTENTICACAO&gt;{{unscape .Authentication.AuthorizationToken}}&lt;/AUTENTICACAO&gt;
            &lt;USUARIO_SERVICO&gt;{{caixaEnv}}&lt;/USUARIO_SERVICO&gt;
            &lt;OPERACAO&gt;INCLUI_BOLETO&lt;/OPERACAO&gt;
            &lt;SISTEMA_ORIGEM&gt;SIGCB&lt;/SISTEMA_ORIGEM&gt;
            &lt;UNIDADE&gt;{{.Agreement.Agency}}&lt;/UNIDADE&gt;
            &lt;DATA_HORA&gt;{{fullDate today}}&lt;/DATA_HORA&gt;
            &lt;/sib:HEADER&gt;
         &lt;DADOS&gt;
            &lt;INCLUI_BOLETO&gt;
              &lt;CODIGO_BENEFICIARIO&gt;{{padLeft (toString .Agreement.AgreementNumber) "0" 7}}&lt;/CODIGO_BENEFICIARIO&gt;
               &lt;TITULO&gt;
                  &lt;NOSSO_NUMERO&gt;{{toString .Title.OurNumber}}&lt;/NOSSO_NUMERO&gt;
                  &lt;NUMERO_DOCUMENTO&gt;{{truncate .Title.DocumentNumber 11}}&lt;/NUMERO_DOCUMENTO&gt;
                  &lt;DATA_VENCIMENTO&gt;{{enDate .Title.ExpireDateTime "-"}}&lt;/DATA_VENCIMENTO&gt;
                  &lt;VALOR&gt;{{toFloatStr .Title.AmountInCents}}&lt;/VALOR&gt;
                  &lt;TIPO_ESPECIE&gt;{{.Title.BoletoTypeCode}}&lt;/TIPO_ESPECIE&gt;
                  &lt;FLAG_ACEITE&gt;S&lt;/FLAG_ACEITE&gt;
                  &lt;DATA_EMISSAO&gt;{{enDate today "-"}}&lt;/DATA_EMISSAO&gt;
                  &lt;JUROS_MORA&gt;
                     &lt;TIPO&gt;ISENTO&lt;/TIPO&gt;
                     &lt;VALOR&gt;0&lt;/VALOR&gt;
                  &lt;/JUROS_MORA&gt;
                  &lt;VALOR_ABATIMENTO&gt;0&lt;/VALOR_ABATIMENTO&gt;
                  &lt;POS_VENCIMENTO&gt;
                     &lt;ACAO&gt;DEVOLVER&lt;/ACAO&gt;
                    &lt;NUMERO_DIAS&gt;0&lt;/NUMERO_DIAS&gt;
                  &lt;/POS_VENCIMENTO&gt;
                  &lt;CODIGO_MOEDA&gt;9&lt;/CODIGO_MOEDA&gt;
                  &lt;PAGADOR&gt;
                     {{if eq .Buyer.Document.Type "CPF"}}
                                                 &lt;CPF&gt;{{.Buyer.Document.Number}}&lt;/CPF&gt;
                             &lt;NOME&gt;{{truncate .Buyer.Name 40}}&lt;/NOME&gt;
                     {{else}}
                                                 &lt;CNPJ&gt;{{.Buyer.Document.Number}}&lt;/CNPJ&gt;
                             &lt;RAZAO_SOCIAL&gt;{{truncate .Buyer.Name 40}}&lt;/RAZAO_SOCIAL&gt;
                                         {{end}}
                     &lt;ENDERECO&gt;
                     &lt;LOGRADOURO&gt;{{clearString (truncateManyFields 40 .Buyer.Address.Street .Buyer.Address.Number .Buyer.Address.Complement)}}&lt;/LOGRADOURO&gt;
                        &lt;BAIRRO&gt;{{clearString (truncate .Buyer.Address.District 15)}}&lt;/BAIRRO&gt;
                        &lt;CIDADE&gt;{{clearString (truncate .Buyer.Address.City 15)}}&lt;/CIDADE&gt;
                        &lt;UF&gt;{{clearString (truncate .Buyer.Address.StateCode 2)}}&lt;/UF&gt;
                        &lt;CEP&gt;{{clearString (truncate .Buyer.Address.ZipCode 8)}}&lt;/CEP&gt;
                     &lt;/ENDERECO&gt;
                  &lt;/PAGADOR&gt;
                  &lt;FICHA_COMPENSACAO&gt;
                     &lt;MENSAGENS&gt;
                        &lt;MENSAGEM&gt;{{clearString (truncate .Title.Instructions 40)}}&lt;/MENSAGEM&gt;
                        &lt;/MENSAGENS&gt;
                  &lt;/FICHA_COMPENSACAO&gt;
                  &lt;RECIBO_PAGADOR&gt;
                     &lt;MENSAGENS&gt;
                        &lt;MENSAGEM&gt;{{clearString (truncate .Title.Instructions 40)}}&lt;/MENSAGEM&gt;
                     &lt;/MENSAGENS&gt;
                  &lt;/RECIBO_PAGADOR&gt;                 
               &lt;/TITULO&gt;
            &lt;/INCLUI_BOLETO&gt;
           &lt;/DADOS&gt;
      &lt;/ext:SERVICO_ENTRADA&gt;
&lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

func getRequestCaixa() string <span class="cov8" title="1">{
        return incluiBoleto
}</span>

func getResponseCaixa() string <span class="cov8" title="1">{
        return responseCaixa
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package caixa

//Response focado sna integracao com a Caixa
const registerBoletoResponseCaixa = `{
    {{if (eq .returnCode "1")}}
        "Errors":[{
            "Code":"{{trim .returnCode}}",
            "Message":"{{trim .returnMessage}}"
        }]
    {{else}}
        "DigitableLine": "{{fmtDigitableLine (trim .digitableLine)}}",
        "BarCodeNumber": "{{trim .barcodeNumber}}",
        "Links": [{
            "href":"{{trim .url}}",
            "rel": "pdf",
            "method":"GET"
        }]

        {{if (ne .ourNumber "0") }}        
        , "OurNumber": "{{trim .ourNumber}}"
        {{end}}    
    {{end}}
}
`

func getAPIResponseCaixa() string <span class="cov8" title="1">{
        return registerBoletoResponseCaixa
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package caixa

import (
        "fmt"
        "strconv"

        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func caixaAccountDigitCalculator(agency, account string) string <span class="cov8" title="1">{
        multiplier := []int{8, 7, 6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2}
        toCheck := fmt.Sprintf("%04s%011s", agency, account)
        return caixaModElevenCalculator(toCheck, multiplier)
}</span>

func caixaModElevenCalculator(a string, m []int) string <span class="cov8" title="1">{
        sum := validations.SumAccountDigits(a, m)
        digit := (sum * 10) % 11
        if digit == 10 </span><span class="cov0" title="0">{
                return "0"
        }</span>
        <span class="cov8" title="1">return strconv.Itoa(digit)</span>
}

func validadeOurNumber(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Title.OurNumber &gt; 999999999999999 </span><span class="cov8" title="1">{
                        return models.NewErrorResponse("MP400", "O nosso número deve conter apenas 15 digitos.")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }

}

func caixaValidateAccountAndDigit(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAccountValid(11)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">errAg := t.Agreement.IsAgencyValid()
                if errAg != nil </span><span class="cov0" title="0">{
                        return errAg
                }</span>
                <span class="cov8" title="1">t.Agreement.CalculateAccountDigit(caixaAccountDigitCalculator)
                return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func caixaAgencyDigitCalculator(agency string) string <span class="cov0" title="0">{
        multiplier := []int{5, 4, 3, 2}
        return validations.ModElevenCalculator(agency, multiplier)
}</span>

func caixaValidateAgency(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAgencyValid()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func caixaValidateBoletoType(b interface{}) error <span class="cov8" title="1">{
        bt := caixaBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package citibank

import (
        "net/http"
        "regexp"
        "strconv"
        "sync"

        "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/metrics"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankCiti struct {
        validate  *models.Validator
        log       *log.Log
        transport *http.Transport
}

func New() (bankCiti, error) <span class="cov8" title="1">{
        var err error
        b := bankCiti{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }

        b.transport, err = util.BuildTLSTransport()
        if err != nil </span><span class="cov0" title="0">{
                return bankCiti{}, err
        }</span>

        <span class="cov8" title="1">b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(citiValidateAgency)
        b.validate.Push(citiValidateAccount)
        b.validate.Push(citiValidateWallet)

        return b, nil</span>
}

//Log retorna a referencia do log
func (b bankCiti) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b bankCiti) RegisterBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{

        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType()

        boleto.Title.OurNumber = calculateOurNumber(boleto)
        r := flow.NewFlow()
        serviceURL := config.Get().URLCiti
        from := getResponseCiti()
        to := getAPIResponseCiti()
        bod := r.From("message://?source=inline", boleto, getRequestCiti(), tmpl.GetFuncMaps())
        bod.To("log://?type=request&amp;url="+serviceURL, b.log)
        var responseCiti string
        var status int
        var err error
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                responseCiti, status, err = b.sendRequest(bod.GetBody().(string))
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return models.BoletoResponse{}, err
        }</span>
        <span class="cov8" title="1">metrics.PushTimingMetric("citibank-register-boleto-online", duration.Seconds())
        bod.To("set://?prop=header", map[string]string{"status": strconv.Itoa(status)})
        bod.To("set://?prop=body", responseCiti)
        bod.To("log://?type=response&amp;url="+serviceURL, b.log)
        ch := bod.Choice()
        ch.When(flow.Header("status").IsEqualTo("200"))
        ch.To("transform://?format=xml", from, to, tmpl.GetFuncMaps())
        ch.Otherwise()
        ch.To("log://?type=response&amp;url="+serviceURL, b.log).To("apierro://")

        switch t := bod.GetBody().(type) </span>{
        case string:<span class="cov8" title="1">
                response := util.ParseJSON(t, new(models.BoletoResponse)).(*models.BoletoResponse)
                if !hasValidResponse(response) </span><span class="cov8" title="1">{
                        return models.BoletoResponse{}, models.NewBadGatewayError("BadGateway")
                }</span>
                <span class="cov8" title="1">return *response, nil</span>
        case models.BoletoResponse:<span class="cov0" title="0">
                return t, nil</span>
        }
        <span class="cov8" title="1">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}

func (b bankCiti) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">return b.RegisterBoleto(boleto)</span>
}

func (b bankCiti) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

func (b bankCiti) sendRequest(body string) (string, int, error) <span class="cov8" title="1">{
        serviceURL := config.Get().URLCiti
        if config.Get().MockMode </span><span class="cov8" title="1">{
                return util.Post(serviceURL, body, config.Get().TimeoutDefault, map[string]string{"Soapaction": "RegisterBoleto"})
        }</span> else<span class="cov0" title="0"> {
                return util.PostTLS(serviceURL, body, config.Get().TimeoutDefault, map[string]string{"Soapaction": "RegisterBoleto"}, b.transport)
        }</span>
}

//GetBankNumber retorna o codigo do banco
func (b bankCiti) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Citibank
}</span>

func calculateOurNumber(boleto *models.BoletoRequest) uint <span class="cov8" title="1">{
        ourNumberWithDigit := strconv.Itoa(int(boleto.Title.OurNumber)) + util.OurNumberDv(strconv.Itoa(int(boleto.Title.OurNumber)), util.MOD11)
        value, _ := strconv.Atoi(ourNumberWithDigit)
        return uint(value)
}</span>

func (b bankCiti) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "Citibank"
}</span>

func getBoletoType() (bt string, btc string) <span class="cov8" title="1">{
        return "DMI", "03"
}</span>

func hasValidResponse(response *models.BoletoResponse) bool <span class="cov8" title="1">{
        return hasValidBarCode(response.BarCodeNumber) &amp;&amp; hasValidDigitableLine(response.DigitableLine)
}</span>

func hasValidBarCode(barCode string) bool <span class="cov8" title="1">{
        if valid, err := regexp.Match(`\S`, []byte(barCode)); err == nil </span><span class="cov8" title="1">{
                return valid
        }</span>
        <span class="cov0" title="0">return false</span>
}

func hasValidDigitableLine(digitableLine string) bool <span class="cov8" title="1">{
        if valid, err := regexp.Match(`\S`, []byte(digitableLine)); err == nil </span><span class="cov8" title="1">{
                return valid
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package citibank

const responseCiti = `
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:s1="http://www.citibank.com.br/comercioeletronico/registerboleto"&gt;
    &lt;soap:Body&gt;
        &lt;s1:RegisterBoletoResponse&gt;
            &lt;actionCode&gt;{{returnCode}}&lt;/actionCode&gt;
            &lt;reasonMessage&gt;{{returnMessage}}&lt;/reasonMessage&gt;
            &lt;TitlBarCd&gt;{{barcodeNumber}}&lt;/TitlBarCd&gt;
            &lt;TitlDgtLine&gt;{{digitableLine}}&lt;/TitlDgtLine&gt;
        &lt;/s1:RegisterBoletoResponse&gt;
    &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;
`

const registerBoletoCiti = `

## SOAPAction:RegisterBoleto
## Content-Type:text/xml

&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;GrpREMColTit&gt;
         &lt;GrpBenf&gt;
            &lt;CdClrSys&gt;745&lt;/CdClrSys&gt;
            &lt;CdIspb&gt;33479023&lt;/CdIspb&gt;
            &lt;CdtrId&gt;{{.Authentication.Username}}&lt;/CdtrId&gt;
            &lt;CdtrNm&gt;{{sanitizeCitibankSpecialCharacteres .Recipient.Name 40}}&lt;/CdtrNm&gt;
            &lt;CdtrTaxId&gt;{{truncate .Recipient.Document.Number 14}}&lt;/CdtrTaxId&gt;
            &lt;CdtrTaxTp&gt;J&lt;/CdtrTaxTp&gt;
         &lt;/GrpBenf&gt;
         &lt;GrpClPgd&gt;
            &lt;DbtrNm&gt;{{sanitizeCitibankSpecialCharacteres .Buyer.Name 50}}&lt;/DbtrNm&gt;
            &lt;DbtrTaxId&gt;{{clearString (truncate .Buyer.Document.Number 14)}}&lt;/DbtrTaxId&gt;
                        {{if (eq .Buyer.Document.Type "CPF")}}
                    &lt;DbtrTaxTp&gt;F&lt;/DbtrTaxTp&gt;
                        {{else}}
                    &lt;DbtrTaxTp&gt;J&lt;/DbtrTaxTp&gt;
                        {{end}}
            &lt;GrpClPgdAdr&gt;
               &lt;DbtrAdrTp&gt;{{sanitizeCitibankSpecialCharacteres (joinSpace .Buyer.Address.Street .Buyer.Address.Number .Buyer.Address.Complement) 40}}&lt;/DbtrAdrTp&gt;
               &lt;DbtrCtrySubDvsn&gt;{{clearString (truncate .Buyer.Address.StateCode 2)}}&lt;/DbtrCtrySubDvsn&gt;
               &lt;DbtrPstCd&gt;{{truncate (extractNumbers .Buyer.Address.ZipCode) 8}}&lt;/DbtrPstCd&gt;
               &lt;DbtrTwnNm&gt;{{clearString (truncate .Buyer.Address.City 15)}}&lt;/DbtrTwnNm&gt;
            &lt;/GrpClPgdAdr&gt;
         &lt;/GrpClPgd&gt;
         &lt;CdOccTp&gt;01&lt;/CdOccTp&gt;
         &lt;DbtrGrntNm&gt; &lt;/DbtrGrntNm&gt;
         &lt;DbtrMsg&gt;{{sanitizeCitibankSpecialCharacteres .Title.Instructions 40}}&lt;/DbtrMsg&gt;
         &lt;TitlAmt&gt;{{.Title.AmountInCents}}&lt;/TitlAmt&gt;
         &lt;TitlBarCdInd&gt;0&lt;/TitlBarCdInd&gt;
         &lt;TitlCcyCd&gt;09&lt;/TitlCcyCd&gt;
         &lt;TitlCiaCdId&gt;{{trimLeft .Title.DocumentNumber "0"}}&lt;/TitlCiaCdId&gt;
         &lt;TitlDueDt&gt;{{enDate .Title.ExpireDateTime "-"}}&lt;/TitlDueDt&gt;
         &lt;TitlInstrNmDtExec&gt;0&lt;/TitlInstrNmDtExec&gt;
         &lt;TitlInstrProtInd&gt; &lt;/TitlInstrProtInd&gt;
         &lt;TitlInstrWrtOffInd&gt; &lt;/TitlInstrWrtOffInd&gt;
         &lt;TitlIOFAmt&gt;0&lt;/TitlIOFAmt&gt;
         &lt;TitlIssDt&gt;{{enDate todayCiti "-"}}&lt;/TitlIssDt&gt;
         &lt;TitlOurNb&gt;{{padLeft (toString .Title.OurNumber) "0" 12}}&lt;/TitlOurNb&gt;
         &lt;TitlPortCd&gt;1&lt;/TitlPortCd&gt;
         &lt;TitlRbtAmt&gt;0&lt;/TitlRbtAmt&gt;
         &lt;TitlTpCd&gt;{{.Title.BoletoTypeCode}}&lt;/TitlTpCd&gt;
         &lt;TitlYourNb&gt;{{trimLeft .Title.DocumentNumber "0"}}&lt;/TitlYourNb&gt;
         &lt;GrpDscnt&gt;
            &lt;TitlDscntAmtOrPrct&gt;0&lt;/TitlDscntAmtOrPrct&gt;
            &lt;TitlDscntEndDt&gt; &lt;/TitlDscntEndDt&gt;
            &lt;TitlDscntTp&gt; &lt;/TitlDscntTp&gt;
         &lt;/GrpDscnt&gt;
         &lt;GrpItrs&gt;
            &lt;TitlItrsAmtOrPrct&gt;0&lt;/TitlItrsAmtOrPrct&gt;
            &lt;TitlItrsStrDt&gt; &lt;/TitlItrsStrDt&gt;
            &lt;TitlItrsTp&gt; &lt;/TitlItrsTp&gt;
         &lt;/GrpItrs&gt;
         &lt;GrpFn&gt;
            &lt;TitlFnAmtOrPrct&gt;0&lt;/TitlFnAmtOrPrct&gt;
            &lt;TitlFnStrDt&gt; &lt;/TitlFnStrDt&gt;
            &lt;TitlFnTp&gt; &lt;/TitlFnTp&gt;
         &lt;/GrpFn&gt;
      &lt;/GrpREMColTit&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

func getRequestCiti() string <span class="cov8" title="1">{
        return registerBoletoCiti
}</span>

func getResponseCiti() string <span class="cov8" title="1">{
        return responseCiti
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package citibank

const registerBoletoResponseCiti = `
        {
                {{if eq .returnCode "0"}}
                   "DigitableLine": "{{fmtDigitableLine (trim .digitableLine)}}",
                   "BarCodeNumber": "{{trim .barcodeNumber}}"
                {{else}}
                 "Errors": [
                        {
                                "Code": "{{trim .returnCode}}",
                                "Message": "{{trim .returnMessage}}"
                        }
                 ]
                {{end}}
    }
`

func getAPIResponseCiti() string <span class="cov8" title="1">{
        return registerBoletoResponseCiti
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package citibank

import (
        "fmt"

        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func citiValidateAgency(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAgencyValid()
                if err != nil </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", err.Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func citiValidateAccount(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Agreement.Account) != 10 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", fmt.Sprintf("A conta junto com o dígito devem conter somente 10 digítos."))
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func citiValidateWallet(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.Wallet &lt; 100 || t.Agreement.Wallet &gt; 999 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", fmt.Sprintf("A wallet deve conter somente 3 digítos."))
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package itau

import (
        "errors"
        "strings"
        "sync"

        . "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/metrics"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankItau struct {
        validate *models.Validator
        log      *log.Log
}

func New() bankItau <span class="cov8" title="1">{
        b := bankItau{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }
        b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(itauValidateAccount)
        b.validate.Push(itauValidateAgency)
        b.validate.Push(itauBoletoTypeValidate)
        return b
}</span>

//Log retorna a referencia do log
func (b bankItau) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b bankItau) GetTicket(boleto *models.BoletoRequest) (string, error) <span class="cov8" title="1">{
        pipe := NewFlow()
        url := config.Get().URLTicketItau
        pipe.From("message://?source=inline", boleto, getRequestTicket(), tmpl.GetFuncMaps())
        pipe.To("log://?type=request&amp;url="+url, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                pipe.To(url, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutToken})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("itau-get-ticket-boleto-time", duration.Seconds())
        pipe.To("log://?type=response&amp;url="+url, b.log)
        ch := pipe.Choice()
        ch.When(Header("status").IsEqualTo("200"))
        ch.To("transform://?format=json", getTicketResponse(), `{{.access_token}}`, tmpl.GetFuncMaps())
        ch.When(Header("status").IsEqualTo("400"))
        ch.To("transform://?format=json", getTicketResponse(), `{{.errorMessage}}`, tmpl.GetFuncMaps())
        ch.To("set://?prop=body", errors.New(pipe.GetBody().(string)))
        ch.When(Header("status").IsEqualTo("403"))
        ch.To("set://?prop=body", errors.New("403 Forbidden"))
        ch.When(Header("status").IsEqualTo("500"))
        ch.To("transform://?format=json", getTicketErrorResponse(), `{{.errorMessage}}`, tmpl.GetFuncMaps())
        ch.To("set://?prop=body", errors.New(pipe.GetBody().(string)))
        ch.Otherwise()
        ch.To("log://?type=request&amp;url="+url, b.log).To("print://?msg=${body}").To("set://?prop=body", errors.New("integration error"))
        switch t := pipe.GetBody().(type) </span>{
        case string:<span class="cov8" title="1">
                return t, nil</span>
        case error:<span class="cov8" title="1">
                return "", t</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

func (b bankItau) RegisterBoleto(input *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        itauURL := config.Get().URLRegisterBoletoItau
        fromResponse := getResponseItau()
        fromResponseError := getResponseErrorItau()
        toAPI := getAPIResponseItau()
        inputTemplate := getRequestItau()

        input.Title.BoletoType, input.Title.BoletoTypeCode = getBoletoType(input)
        exec := NewFlow().From("message://?source=inline", input, inputTemplate, tmpl.GetFuncMaps())
        exec.To("log://?type=request&amp;url="+itauURL, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                exec.To(itauURL, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutRegister})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("itau-register-boleto-time", duration.Seconds())
        exec.To("log://?type=response&amp;url="+itauURL, b.log)

        ch := exec.Choice()
        ch.When(Header("status").IsEqualTo("200"))
        ch.To("transform://?format=json", fromResponse, toAPI, tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))

        headerMap := exec.GetHeader()

        if status, exist := headerMap["Content-Type"]; exist &amp;&amp; strings.Contains(status, "text/html") </span><span class="cov0" title="0">{
                exec.To("set://?prop=body", `{"codigo":"501","mensagem":"Error"}`)
                ch.When(Header("Content-Type").IsEqualTo(status))
                ch.To("transform://?format=json", fromResponseError, toAPI, tmpl.GetFuncMaps())
        }</span> else<span class="cov8" title="1"> if status, exist = headerMap["status"]; exist &amp;&amp; status != "200" </span><span class="cov8" title="1">{
                ch.When(Header("status").IsEqualTo(status))
                ch.To("transform://?format=json", fromResponseError, toAPI, tmpl.GetFuncMaps())
                ch.To("unmarshall://?format=json", new(models.BoletoResponse))
        }</span>

        <span class="cov8" title="1">ch.Otherwise()
        ch.To("log://?type=response&amp;url="+itauURL, b.log).To("apierro://")

        switch t := exec.GetBody().(type) </span>{
        case *models.BoletoResponse:<span class="cov8" title="1">
                return *t, nil</span>
        case error:<span class="cov0" title="0">
                return models.BoletoResponse{}, t</span>
        }
        <span class="cov0" title="0">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}

func (b bankItau) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">if ticket, err := b.GetTicket(boleto); err != nil </span><span class="cov8" title="1">{
                return models.BoletoResponse{Errors: errs}, err
        }</span> else<span class="cov8" title="1"> {
                boleto.Authentication.AuthorizationToken = ticket
        }</span>
        <span class="cov8" title="1">return b.RegisterBoleto(boleto)</span>
}

func (b bankItau) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

//GetBankNumber retorna o codigo do banco
func (b bankItau) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Itau
}</span>

func (b bankItau) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "Itau"
}</span>

func itauBoletoTypes() map[string]string <span class="cov8" title="1">{
        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["DM"] = "01"  //Duplicata Mercantil
                m["NP"] = "02"  //Nota Promissória
                m["RC"] = "05"  //Recibo
                m["DS"] = "08"  //Duplicata de serviços
                m["BDP"] = "18" //Boleto de proposta
                m["OUT"] = "99" //Outros
        }</span>)
        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "DM", "01"
        }</span>
        <span class="cov8" title="1">btm := itauBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "DM", "01"
        }</span>

        <span class="cov8" title="1">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package itau

const registerItau = `
## Accept: application/vnd.itau
## access_token: {{.Authentication.AuthorizationToken}}
## itau-chave: {{.Authentication.AccessKey}}
## identificador: {{.Recipient.Document.Number}}
## Content-Type: application/json

{
    "tipo_ambiente": {{itauEnv}},
    "tipo_registro": 1,
    "tipo_cobranca": 1,
    "tipo_produto": "00006",
    "subproduto": "00008",
    "beneficiario": {
        "cpf_cnpj_beneficiario": "{{extractNumbers .Recipient.Document.Number}}",
        "agencia_beneficiario": "{{padLeft .Agreement.Agency "0" 4}}",
        "conta_beneficiario": "{{padLeft .Agreement.Account "0" 7}}",
        "digito_verificador_conta_beneficiario": "{{.Agreement.AccountDigit}}"
    },
    "identificador_titulo_empresa": "{{unescapeHtmlString (truncate .Recipient.Name 25)}}",
    "uso_banco": "",
    "titulo_aceite": "S",
    "pagador": {
        "cpf_cnpj_pagador": "{{extractNumbers .Buyer.Document.Number}}",
        "nome_pagador": "{{unescapeHtmlString (truncate .Buyer.Name 30)}}",
        "logradouro_pagador": "{{unescapeHtmlString ( escapeStringOnJson (truncate (concat .Buyer.Address.Street " " .Buyer.Address.Number " " .Buyer.Address.Complement) 40)) }}",        
        "bairro_pagador": "{{unescapeHtmlString ( escapeStringOnJson (truncate .Buyer.Address.District 15))}}",
        "cidade_pagador": "{{unescapeHtmlString ( escapeStringOnJson (truncate .Buyer.Address.City 20))}}",
        "uf_pagador": "{{truncate .Buyer.Address.StateCode 2}}",
        "cep_pagador": "{{escapeStringOnJson (truncate (extractNumbers .Buyer.Address.ZipCode) 8)}}",
        "grupo_email_pagador": [
            {
                "email_pagador": ""
            }
        ]
    },
    "tipo_carteira_titulo": "{{.Agreement.Wallet}}",
    "moeda": {
        "codigo_moeda_cnab": "09",
        "quantidade_moeda": ""
    },
    "nosso_numero": "{{padLeft (toString .Title.OurNumber) "0" 8}}",
    "digito_verificador_nosso_numero": "{{mod10ItauDv (padLeft (toString .Title.OurNumber) "0" 8) (padLeft .Agreement.Agency "0" 4) (padLeft .Agreement.Account "0" 7) .Agreement.Wallet}}",
    "codigo_barras": "",
    "data_vencimento": "{{enDate .Title.ExpireDateTime "-"}}",
    "valor_cobrado": "{{padLeft (toString64 .Title.AmountInCents) "0" 16}}",
    "seu_numero": "{{padLeft .Title.DocumentNumber "0" 10}}",
    "especie": "{{ .Title.BoletoTypeCode}}",
    "data_emissao": "{{enDate (today) "-"}}",    
    "tipo_pagamento": 1,
    "indicador_pagamento_parcial": "false",
    "quantidade_pagamento_parcial": "0",
    "quantidade_parcelas": "0",
    "instrucao_cobranca_1": "",
    "quantidade_dias_1": "",
    "data_instrucao_1": "",
    "instrucao_cobranca_2": "",
    "quantidade_dias_2": "",
    "data_instrucao_2": "",
    "instrucao_cobranca_3": "",
    "quantidade_dias_3": "",
    "data_instrucao_3": "",
    "valor_abatimento": "",
    "juros": {
        "data_juros": "",
        "tipo_juros": 5,
        "valor_juros": "",
        "percentual_juros": ""
    },
    "multa": {
        "data_multa": "",
        "tipo_multa": 3,
        "valor_multa": "",
        "percentual_multa": ""
    },    
    "grupo_desconto": [{
        "data_desconto": "",
        "tipo_desconto": 0,
        "valor_desconto": "",
        "percentual_desconto": ""
    }],    
    "recebimento_divergente": {
        "tipo_autorizacao_recebimento": "3",
        "tipo_valor_percentual_recebimento": "",
        "valor_minimo_recebimento": "",
        "percentual_minimo_recebimento": "",
        "valor_maximo_recebimento": "",
        "percentual_maximo_recebimento": ""
    },
    "grupo_rateio": []
}

`

const itauGetTicketRequest = `## Authorization:Basic {{base64 (concat .Authentication.Username ":" .Authentication.Password)}}
## Content-Type: application/x-www-form-urlencoded
scope=readonly&amp;grant_type=client_credentials&amp;clientId={{.Authentication.Username}}&amp;clientSecret={{.Authentication.Password}}`

const ticketResponse = `{
    "codigo":"{{errorCode}}",
    "mensagem":"{{errorMessage}}",
    "access_token": "{{access_token}}",
    "Message":"{{errorMessage}}"
}`

const ticketErrorResponse = `{
    "Message":"{{errorMessage}}"
}`

func getRequestTicket() string <span class="cov8" title="1">{
        return itauGetTicketRequest
}</span>

func getTicketResponse() string <span class="cov8" title="1">{
        return ticketResponse
}</span>

func getTicketErrorResponse() string <span class="cov8" title="1">{
        return ticketErrorResponse
}</span>

func getRequestItau() string <span class="cov8" title="1">{
        return registerItau
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package itau

const registerBoletoResponseItau = `{
    {{if (hasErrorTags . "errorCode") | (hasErrorTags . "errorMessage")}}
        "Errors": [
            {                    
                "Code": "{{trim .errorCode}}",
                "Message": "{{trim .errorMessage}}"
            }
        ]
    {{else}}
        "DigitableLine": "{{fmtDigitableLine (trim .digitableLine)}}",
        "BarCodeNumber": "{{trim .barcodeNumber}}"
    {{end}}
}
`

const boletoResponseItau = `
{                
        "codigo_barras": "{{barcodeNumber}}",
        "numero_linha_digitavel": "{{digitableLine}}"        
}
`

const boletoResponseErrorItau = `
{
    "codigo":"{{errorCode}}",
    "mensagem":"{{errorMessage}}"        
}
`

func getResponseItau() string <span class="cov8" title="1">{
        return boletoResponseItau
}</span>

func getAPIResponseItau() string <span class="cov8" title="1">{
        return registerBoletoResponseItau
}</span>

func getResponseErrorItau() string <span class="cov8" title="1">{
        return boletoResponseErrorItau
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package itau

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func itauValidateAccount(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAccountValid(7)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func itauValidateAgency(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                err := t.Agreement.IsAgencyValid()
                if err != nil </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", err.Error())
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func itauBoletoTypeValidate(b interface{}) error <span class="cov8" title="1">{
        bt := itauBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package models

import (
        "fmt"
        "regexp"

        "github.com/mundipagg/boleto-api/util"
)

// Agreement afiliação do cliente com o bano
type Agreement struct {
        AgreementNumber uint   `json:"agreementNumber,omitempty"`
        Wallet          uint16 `json:"wallet,omitempty"`
        WalletVariation uint16 `json:"walletVariation,omitempty"`
        Agency          string `json:"agency,omitempty"`
        AgencyDigit     string `json:"agencyDigit,omitempty"`
        Account         string `json:"account,omitempty"`
        AccountDigit    string `json:"accountDigit,omitempty"`
}

// IsAgencyValid retorna se é uma agência válida
func (a *Agreement) IsAgencyValid() error <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        ag := re.ReplaceAllString(a.Agency, "")
        if len(ag) &lt; 5 &amp;&amp; len(ag) &gt; 0 </span><span class="cov8" title="1">{
                a.Agency = util.PadLeft(ag, "0", 4)
                return nil
        }</span>
        <span class="cov8" title="1">return NewErrorResponse("MPAgency", "Agência inválida, deve conter até 4 dígitos")</span>
}

// CalculateAgencyDigit calcula dígito da agência
func (a *Agreement) CalculateAgencyDigit(digitCalculator func(agency string) string) <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        ad := re.ReplaceAllString(a.AgencyDigit, "")
        if len(ad) == 1 </span><span class="cov8" title="1">{
                a.AgencyDigit = ad
        }</span> else<span class="cov8" title="1"> {
                a.AgencyDigit = digitCalculator(a.Agency)
        }</span>
}

// IsAccountValid retorna se é uma conta válida
func (a *Agreement) IsAccountValid(accountLength int) error <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        ac := re.ReplaceAllString(a.Account, "")
        if len(ac) &lt; accountLength+1 &amp;&amp; len(ac) &gt; 0 </span><span class="cov8" title="1">{
                a.Account = util.PadLeft(ac, "0", uint(accountLength))
                return nil
        }</span>
        <span class="cov8" title="1">return NewErrorResponse("MPAccount", fmt.Sprintf("Conta inválida, deve conter até %d dígitos", accountLength))</span>
}

//CalculateAccountDigit calcula dígito da conta
func (a *Agreement) CalculateAccountDigit(digitCalculator func(agency, account string) string) <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        ad := re.ReplaceAllString(a.AccountDigit, "")
        if len(ad) == 1 </span><span class="cov8" title="1">{
                a.AccountDigit = ad
        }</span> else<span class="cov8" title="1"> {
                a.AccountDigit = digitCalculator(a.Agency, a.Account)
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package models

import (
        "time"

        "github.com/mundipagg/boleto-api/util"

        "gopkg.in/mgo.v2/bson"

        "github.com/mundipagg/boleto-api/config"

        "github.com/PMoneda/flow"
        "github.com/google/uuid"

        "fmt"

        "encoding/json"
        "strconv"
)

// BoletoRequest entidade de entrada para o boleto
type BoletoRequest struct {
        Authentication Authentication `json:"authentication"`
        Agreement      Agreement      `json:"agreement"`
        Title          Title          `json:"title"`
        Recipient      Recipient      `json:"recipient"`
        Buyer          Buyer          `json:"buyer"`
        BankNumber     BankNumber     `json:"bankNumber"`
        RequestKey     string         `json:"requestKey,omitempty"`
}

// BoletoResponse entidade de saída para o boleto
type BoletoResponse struct {
        StatusCode    int    `json:"-"`
        Errors        Errors `json:"errors,omitempty"`
        ID            string `json:"id,omitempty"`
        DigitableLine string `json:"digitableLine,omitempty"`
        BarCodeNumber string `json:"barCodeNumber,omitempty"`
        OurNumber     string `json:"ourNumber,omitempty"`
        Links         []Link `json:"links,omitempty"`
}

//Link é um tipo padrão no restfull para satisfazer o HATEOAS
type Link struct {
        Href   string `json:"href,omitempty"`
        Rel    string `json:"rel,omitempty"`
        Method string `json:"method,omitempty"`
}

// BoletoView contem as informações que serão preenchidas no boleto
type BoletoView struct {
        ID            bson.ObjectId `bson:"_id,omitempty"`
        UID           string
        SecretKey     string
        PublicKey     string        `json:"pk,omitempty"`
        Format        string        `json:"format,omitempty"`
        Boleto        BoletoRequest `json:"boleto,omitempty"`
        BankID        BankNumber    `json:"bankId,omitempty"`
        CreateDate    time.Time     `json:"createDate,omitempty"`
        BankNumber    string        `json:"bankNumber,omitempty"`
        DigitableLine string        `json:"digitableLine,omitempty"`
        OurNumber     string        `json:"ourNumber,omitempty"`
        Barcode       string        `json:"barcode,omitempty"`
        Barcode64     string        `json:"barcode64,omitempty"`
        Links         []Link        `json:"links,omitempty"`
}

// NewBoletoView cria um novo objeto view de boleto a partir de um boleto request, codigo de barras e linha digitavel
func NewBoletoView(boleto BoletoRequest, response BoletoResponse, bankName string) BoletoView <span class="cov8" title="1">{
        boleto.Authentication = Authentication{}
        uid, _ := uuid.NewUUID()
        id := bson.NewObjectId()
        view := BoletoView{
                ID:            id,
                UID:           uid.String(),
                SecretKey:     uid.String(),
                BankID:        boleto.BankNumber,
                Boleto:        boleto,
                Barcode:       response.BarCodeNumber,
                DigitableLine: response.DigitableLine,
                OurNumber:     response.OurNumber,
                BankNumber:    boleto.BankNumber.GetBoletoBankNumberAndDigit(),
                CreateDate:    time.Now(),
        }
        view.GeneratePublicKey()
        view.Links = view.CreateLinks()
        if len(response.Links) &gt; 0 &amp;&amp; bankName == "BradescoShopFacil" </span><span class="cov0" title="0">{
                view.Links = append(view.Links, response.Links[0])
        }</span>
        <span class="cov8" title="1">return view</span>
}

//EncodeURL tranforma o boleto view na forma que será escrito na url
func (b *BoletoView) EncodeURL(format string) string <span class="cov8" title="1">{
        idBson, _ := b.ID.MarshalText()
        _url := fmt.Sprintf("%s?fmt=%s&amp;id=%s&amp;pk=%s", config.Get().AppURL, format, string(idBson), b.PublicKey)

        return _url
}</span>

//CreateLinks cria a lista de links com os formatos suportados
func (b *BoletoView) CreateLinks() []Link <span class="cov8" title="1">{
        links := make([]Link, 0, 3)
        for _, f := range []string{"html", "pdf"} </span><span class="cov8" title="1">{
                links = append(links, Link{Href: b.EncodeURL(f), Rel: f, Method: "GET"})
        }</span>
        <span class="cov8" title="1">return links</span>
}

//ToJSON tranforma o boleto view em json
func (b BoletoView) ToJSON() string <span class="cov0" title="0">{
        json, _ := json.Marshal(b)
        return string(json)
}</span>

//GeneratePublicKey Gera a chave pública criptografada para geração da URL do boleto
func (b *BoletoView) GeneratePublicKey() <span class="cov8" title="1">{
        s := b.SecretKey + b.CreateDate.String() + b.Barcode + b.Boleto.Buyer.Document.Number + strconv.FormatUint(b.Boleto.Title.AmountInCents, 10)
        b.PublicKey = util.Sha256(s, "hex")
}</span>

// BankNumber número de identificação do banco
type BankNumber int

// IsBankNumberValid verifica se o banco enviado existe
func (b BankNumber) IsBankNumberValid() bool <span class="cov0" title="0">{
        switch b </span>{
        case BancoDoBrasil, Itau, Santander, Caixa, Bradesco, Citibank:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

//GetBoletoBankNumberAndDigit Retorna o numero da conta do banco do boleto
func (b BankNumber) GetBoletoBankNumberAndDigit() string <span class="cov8" title="1">{
        switch b </span>{
        case BancoDoBrasil:<span class="cov0" title="0">
                return "001-9"</span>
        case Caixa:<span class="cov0" title="0">
                return "104-0"</span>
        case Santander:<span class="cov0" title="0">
                return "033-7"</span>
        case Itau:<span class="cov0" title="0">
                return "341-7"</span>
        case Bradesco:<span class="cov0" title="0">
                return "237-2"</span>
        case Pefisa:<span class="cov0" title="0">
                return "174"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

const (
        // BancoDoBrasil constante do Banco do Brasil
        BancoDoBrasil = 1

        // Santander constante do Santander
        Santander = 33

        // Itau constante do Itau
        Itau = 341

        //Bradesco constante do Bradesco
        Bradesco = 237
        // Caixa constante do Caixa
        Caixa = 104

        // Citibank constante do Citi
        Citibank = 745

        //Real constante do REal
        Real = 9

        // Pefisa constante do Pefisa
        Pefisa = 174
)

// BoletoErrorConector é um connector flow para criar um objeto de erro
func BoletoErrorConector(e *flow.ExchangeMessage, u flow.URI, params ...interface{}) error <span class="cov0" title="0">{
        b := "Erro interno"
        switch t := e.GetBody().(type) </span>{
        case error:<span class="cov0" title="0">
                b = t.Error()</span>
        case string:<span class="cov0" title="0">
                b = t</span>
        }

        <span class="cov0" title="0">st, err := strconv.Atoi(e.GetHeader("status"))
        if err != nil </span><span class="cov0" title="0">{
                st = 0
        }</span>
        <span class="cov0" title="0">resp := BoletoResponse{}
        resp.Errors = make(Errors, 0, 0)
        resp.Errors.Append("MP"+e.GetHeader("status"), b)
        resp.StatusCode = st
        e.SetBody(resp)
        return nil</span>
}

//HasErrors verify if Response has any error
func (b *BoletoResponse) HasErrors() bool <span class="cov0" title="0">{
        return b.Errors != nil &amp;&amp; len(b.Errors) &gt; 0
}</span>

//GetBoletoResponseError Retorna um BoletoResponse com um erro específico
func GetBoletoResponseError(code, message string) BoletoResponse <span class="cov0" title="0">{
        resp := BoletoResponse{}
        resp.Errors = make(Errors, 0, 0)
        resp.Errors.Append(code, message)
        return resp
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package models

import "gopkg.in/mgo.v2/bson"

//Credentials Credenciais para requisição de Registro de Boleto
type Credentials struct {
        ID       bson.ObjectId `bson:"_id,omitempty"`
        UserKey  string
        Username string `bson:"username,omitempty"`
        Password string `bson:"password,omitempty"`
}

//NewCredentials Cria uma instância de Credential
func NewCredentials(k, p string) *Credentials <span class="cov0" title="0">{
        return &amp;Credentials{
                UserKey:  k,
                Password: p,
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package models

import (
        "regexp"
        "strings"
)

// Document nó com o tipo de documento e número do documento
type Document struct {
        Type   string `json:"type,omitempty"`
        Number string `json:"number,omitempty"`
}

// IsCPF diz se o DocumentType é um CPF
func (d Document) IsCPF() bool <span class="cov8" title="1">{
        return strings.ToUpper(d.Type) == "CPF"
}</span>

// IsCNPJ diz se o DocumentType é um CNPJ
func (d Document) IsCNPJ() bool <span class="cov8" title="1">{
        return strings.ToUpper(d.Type) == "CNPJ"
}</span>

// ValidateCPF verifica se é um CPF válido
func (d *Document) ValidateCPF() error <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        cpf := re.ReplaceAllString(string(d.Number), "")
        if len(cpf) == 11 </span><span class="cov8" title="1">{
                d.Number = cpf
                return nil
        }</span>
        <span class="cov8" title="1">return NewErrorResponse("MPDocumentNumber", "CPF inválido")</span>
}

// ValidateCNPJ verifica se é um CNPJ válido
func (d *Document) ValidateCNPJ() error <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        cnpj := re.ReplaceAllString(string(d.Number), "")
        if len(cnpj) == 14 </span><span class="cov8" title="1">{
                d.Number = cnpj
                return nil
        }</span>
        <span class="cov8" title="1">return NewErrorResponse("MPDocumentNumber", "CNPJ inválido")</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package models

// IErrorResponse interface para implementar Error
type IErrorResponse interface {
        Error() string
        ErrorCode() string
}

// DataError objeto de erro
type ArrayDataError struct {
        Error []ErrorResponse `json:"error"`
}

// ErrorResponse objeto de erro
type ErrorResponse struct {
        Code    string `json:"code,omitempty"`
        Message string `json:"message,omitempty"`
}

//NewErrorResponse cria um novo objeto de ErrorReponse com código e mensagem
func NewErrorResponse(code, msg string) ErrorResponse <span class="cov8" title="1">{
        return ErrorResponse{Code: code, Message: msg}
}</span>

// ErrorCode retorna código do erro
func (e ErrorResponse) ErrorCode() string <span class="cov0" title="0">{
        return e.Code
}</span>

func (e ErrorResponse) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Errors coleção de erros
type Errors []ErrorResponse

// NewErrors cria nova coleção de erros vazia
func NewErrors() Errors <span class="cov8" title="1">{
        return []ErrorResponse{}
}</span>

// NewErrorCollection cria nova coleção de erros
func NewErrorCollection(errorResponse ErrorResponse) Errors <span class="cov0" title="0">{
        return []ErrorResponse{errorResponse}
}</span>

// NewSingleErrorCollection cria nova coleção de erros com 1 item
func NewSingleErrorCollection(code, msg string) Errors <span class="cov0" title="0">{
        return NewErrorCollection(NewErrorResponse(code, msg))
}</span>

// GatewayTimeout objeto para erros 404 da aplicação: ex boleto não encontrado
type GatewayTimeout ErrorResponse

//NewGatewayTimeout cria um novo objeto NewGatewayTimeout a partir de uma mensagem original e final
func NewGatewayTimeout(code, msg string) GatewayTimeout <span class="cov0" title="0">{
        return GatewayTimeout{Message: msg, Code: code}
}</span>

//ErrorCode ErrorCode
func (e GatewayTimeout) ErrorCode() string <span class="cov0" title="0">{
        return e.Code
}</span>

//Error Error
func (e GatewayTimeout) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

//InternalServerError IServerError interface para implementar Error
type InternalServerError ErrorResponse

//NewInternalServerError cria um novo objeto InternalServerError a partir de uma mensagem original e final
func NewInternalServerError(code, msg string) InternalServerError <span class="cov0" title="0">{
        return InternalServerError{Message: msg, Code: code}
}</span>

//ErrorCode Message retorna a mensagem final para o usuário
func (e InternalServerError) ErrorCode() string <span class="cov0" title="0">{
        return e.Code
}</span>

//Error retorna o erro original
func (e InternalServerError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

//HttpNotFound interface para implementar Error
type HttpNotFound ErrorResponse

//NewHTTPNotFound cria um novo objeto NewHttpNotFound a partir de uma mensagem original e final
func NewHTTPNotFound(code, msg string) HttpNotFound <span class="cov0" title="0">{
        return HttpNotFound{Message: msg, Code: code}
}</span>

//ErrorCode Message retorna a mensagem final para o usuário
func (e HttpNotFound) ErrorCode() string <span class="cov0" title="0">{
        return e.Code
}</span>

//Error retorna o erro original
func (e HttpNotFound) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

//FormatError interface para implementar Error
type FormatError ErrorResponse

//NewFormatError cria um novo objeto de FormatError com descrição do erro
func NewFormatError(e string) FormatError <span class="cov0" title="0">{
        return FormatError{Message: e}
}</span>

//Error Retorna um erro code
func (e FormatError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

//ErrorCode Retorna um erro code
func (e FormatError) ErrorCode() string <span class="cov0" title="0">{
        return e.Code
}</span>

//BadGatewayError interface para implementar Error
type BadGatewayError ErrorResponse

//NewBadGatewayError cria um novo objeto de BadGatewayError com descrição do erro
func NewBadGatewayError(e string) BadGatewayError <span class="cov0" title="0">{
        return BadGatewayError{Message: e}
}</span>

//Error Retorna um erro code
func (e BadGatewayError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

//ErrorCode Retorna um erro code
func (e BadGatewayError) ErrorCode() string <span class="cov0" title="0">{
        return e.Code
}</span>

//Append adiciona mais um erro na coleção
func (e *Errors) Append(code, message string) <span class="cov8" title="1">{
        *e = append(*e, ErrorResponse{Code: code, Message: message})
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package models

import "strings"

type Fine struct {
        Type string  `json:"type,omitempty"`
        Days int     `json:"days,omitempty"`
        Rate float64 `json:"rate,omitempty"`
}

//IsValid Valida informações sobre o juros
func (f *Fine) IsValid(amountInCents int) bool <span class="cov8" title="1">{
        if f.Days &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if !f.isValidRate(amountInCents) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (f *Fine) isValidRate(amountInCents int) bool <span class="cov8" title="1">{
        pcond := f.isValidPercentualRate()
        ncond := f.isValidNominalRate(amountInCents)

        //Representa uma lógica XOR, onde será true se, e somente se, uma das condições forem verdade
        return (!pcond &amp;&amp; ncond) || (pcond &amp;&amp; !ncond)
}</span>

func (f *Fine) isValidPercentualRate() bool <span class="cov8" title="1">{
        if strings.ToLower(f.Type) != Percentual </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if f.Rate &lt; 0 || f.Rate &gt; 1.0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (f *Fine) isValidNominalRate(amountInCents int) bool <span class="cov8" title="1">{
        if strings.ToLower(f.Type) != Nominal </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if amountInCents &lt;= 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">rate := float64(int(f.Rate)) / float64(amountInCents)

        return rate &lt;= 0.01</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package models

import (
        "fmt"
        "regexp"
        "time"

        "github.com/mundipagg/boleto-api/util"
)

// Title título de cobrança de entrada
type Title struct {
        CreateDate     time.Time `json:"createDate,omitempty"`
        ExpireDateTime time.Time `json:"expireDateTime,omitempty"`
        ExpireDate     string    `json:"expireDate,omitempty"`
        AmountInCents  uint64    `json:"amountInCents,omitempty"`
        OurNumber      uint      `json:"ourNumber,omitempty"`
        Instructions   string    `json:"instructions,omitempty"`
        DocumentNumber string    `json:"documentNumber,omitempty"`
        NSU            string    `json:"nsu,omitempty"`
        BoletoType     string    `json:"boletoType,omitempty"`
        Rules          Rules     `json:"rules,omitempty"`
        BoletoTypeCode string
}

//ValidateInstructionsLength valida se texto das instruções possui quantidade de caracteres corretos
func (t Title) ValidateInstructionsLength(max int) error <span class="cov8" title="1">{
        if len(t.Instructions) &gt; max </span><span class="cov8" title="1">{
                return NewErrorResponse("MPInstructions", fmt.Sprintf("Instruções não podem passar de %d caracteres", max))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//ValidateDocumentNumber número do documento
func (t *Title) ValidateDocumentNumber() error <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        ad := re.ReplaceAllString(t.DocumentNumber, "")
        if ad == "" </span><span class="cov8" title="1">{
                t.DocumentNumber = ad
        }</span> else<span class="cov8" title="1"> if len(ad) &lt; 10 </span><span class="cov8" title="1">{
                t.DocumentNumber = util.PadLeft(ad, "0", 10)
        }</span> else<span class="cov8" title="1"> {
                t.DocumentNumber = ad[:10]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//IsExpireDateValid retorna um erro se a data de expiração for inválida
func (t *Title) IsExpireDateValid() error <span class="cov8" title="1">{
        d, err := parseDate(t.ExpireDate)
        if err != nil </span><span class="cov8" title="1">{
                return NewErrorResponse("MPExpireDate", fmt.Sprintf("Data em um formato inválido, esperamos AAAA-MM-DD e recebemos %s", t.ExpireDate))
        }</span>
        <span class="cov8" title="1">n, _ := parseDate(util.BrNow().Format("2006-01-02"))
        t.CreateDate = n
        t.ExpireDateTime = d
        if t.CreateDate.After(t.ExpireDateTime) </span><span class="cov8" title="1">{
                return NewErrorResponse("MPExpireDate", "Data de expiração não pode ser menor que a data de hoje")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

//IsAmountInCentsValid retorna um erro se o valor em centavos for inválido
func (t *Title) IsAmountInCentsValid() error <span class="cov8" title="1">{
        if t.AmountInCents &lt; 1 </span><span class="cov8" title="1">{
                return NewErrorResponse("MPAmountInCents", "Valor não pode ser menor do que 1 centavo")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseDate(t string) (time.Time, error) <span class="cov8" title="1">{
        date, err := time.Parse("2006-01-02", t)
        if err != nil </span><span class="cov8" title="1">{
                return time.Now(), err
        }</span>
        <span class="cov8" title="1">return date, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package models

//Validator estrutura de validação
type Validator struct {
        Rules []Rule
}

//Rule é a regra que será adiciona a camada de validação
type Rule func(interface{}) error

//Push insere no Validator uma nova regra
func (v *Validator) Push(r Rule) <span class="cov0" title="0">{
        v.Rules = append(v.Rules, r)
}</span>

//Assert aplica todas as validações no objeto passado como parâmetro
func (v *Validator) Assert(o interface{}) Errors <span class="cov0" title="0">{
        errs := NewErrors()
        for _, assert := range v.Rules </span><span class="cov0" title="0">{
                err := assert(o)
                switch t := err.(type) </span>{
                case ErrorResponse:<span class="cov0" title="0">
                        errs = append(errs, t)</span>
                default:<span class="cov0" title="0">
                        if err != nil </span><span class="cov0" title="0">{
                                errs.Append(err.Error(), "Erro interno")
                        }</span>
                }
        }
        <span class="cov0" title="0">return errs</span>
}

//NewValidator retorna nova instância de validação
func NewValidator() *Validator <span class="cov0" title="0">{
        return &amp;Validator{}
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package parser

import "github.com/beevik/etree"

//Rule é o tipo de dados que faz o de-para de uma query na mensagem para uma key no dicionário de valores
type Rule struct {
        XMLQuery string
        MapKey   string
}

//TranslatorMap contem as regras de tradução e extração de uma mensagem
type TranslatorMap struct {
        rules []Rule
}

//AddRule adiciona uma regra nova no objeto de tradução
func (t *TranslatorMap) AddRule(r Rule) <span class="cov8" title="1">{
        t.rules = append(t.rules, r)
}</span>

//GetRules retorna todas as regras do tradutor
func (t *TranslatorMap) GetRules() []Rule <span class="cov8" title="1">{
        return t.rules
}</span>

//NewTranslatorMap cria uma novo objeto de tradução
func NewTranslatorMap() *TranslatorMap <span class="cov8" title="1">{
        t := TranslatorMap{}
        t.rules = make([]Rule, 0, 0)
        return &amp;t
}</span>

//ParseXML executa o parse do XML e retorna uma estrutura de arvore do documento
func ParseXML(xmlDoc string) (*etree.Document, error) <span class="cov8" title="1">{
        doc := etree.NewDocument()
        if err := doc.ReadFromString(xmlDoc); err != nil </span><span class="cov0" title="0">{
                return etree.NewDocument(), err
        }</span>
        <span class="cov8" title="1">return doc, nil</span>
}

//ExtractValuesFromXML extrai os valores do documento de acordo com uma lista de regras de "de-para"
func ExtractValuesFromXML(doc *etree.Document, translate *TranslatorMap) map[string]string <span class="cov8" title="1">{
        values := make(map[string]string)
        for _, rule := range translate.rules </span><span class="cov8" title="1">{
                for _, t := range doc.FindElements(rule.XMLQuery) </span><span class="cov8" title="1">{
                        values[rule.MapKey] = t.Text()
                        break</span>
                }
        }
        <span class="cov8" title="1">return values</span>
}

// ExtractValues extrai valores de uma string
func ExtractValues(xmlDoc string, translator *TranslatorMap) (map[string]string, error) <span class="cov0" title="0">{
        doc, err := ParseXML(xmlDoc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ExtractValuesFromXML(doc, translator), nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package pefisa

import (
        "errors"
        "strconv"
        "strings"
        "sync"

        . "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/metrics"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankPefisa struct {
        validate *models.Validator
        log      *log.Log
}

func New() bankPefisa <span class="cov8" title="1">{
        b := bankPefisa{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }

        b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(pefisaBoletoTypeValidate)

        return b
}</span>

func (b bankPefisa) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b bankPefisa) GetToken(boleto *models.BoletoRequest) (string, error) <span class="cov8" title="1">{

        pipe := NewFlow()
        url := config.Get().URLPefisaToken

        pipe.From("message://?source=inline", boleto, getRequestToken(), tmpl.GetFuncMaps())
        pipe.To("log://?type=request&amp;url="+url, b.log)

        duration := util.Duration(func() </span><span class="cov8" title="1">{
                pipe.To(url, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutToken})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("pefisa-get-token-boleto-time", duration.Seconds())
        pipe.To("log://?type=response&amp;url="+url, b.log)
        ch := pipe.Choice()
        ch.When(Header("status").IsEqualTo("200"))
        ch.To("transform://?format=json", getTokenResponse(), `{{.access_token}}`, tmpl.GetFuncMaps())

        ch.When(Header("status").IsEqualTo("401"))
        ch.To("transform://?format=json", getTokenErrorResponse(), `{{.error_description}}`, tmpl.GetFuncMaps())
        ch.To("set://?prop=body", errors.New(pipe.GetBody().(string)))

        ch.Otherwise()
        ch.To("log://?type=request&amp;url="+url, b.log).To("print://?msg=${body}").To("set://?prop=body", errors.New("integration error"))
        switch t := pipe.GetBody().(type) </span>{
        case string:<span class="cov8" title="1">

                return t, nil</span>
        case error:<span class="cov0" title="0">
                return "", t</span>
        }
        <span class="cov0" title="0">return "", nil</span>

}

func (b bankPefisa) RegisterBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        pefisaURL := config.Get().URLPefisaRegister

        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType(boleto)

        exec := NewFlow().From("message://?source=inline", boleto, getRequestPefisa(), tmpl.GetFuncMaps())
        exec.To("log://?type=request&amp;url="+pefisaURL, b.log)

        var response string
        var status int
        var err error
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                response, status, err = b.sendRequest(exec.GetBody().(string), boleto.Authentication.AuthorizationToken)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return models.BoletoResponse{}, err
        }</span>

        <span class="cov8" title="1">metrics.PushTimingMetric("pefisa-register-boleto-time", duration.Seconds())
        exec.To("set://?prop=header", map[string]string{"status": strconv.Itoa(status)})
        exec.To("set://?prop=body", response)
        exec.To("log://?type=response&amp;url="+pefisaURL, b.log)

        if status == 200 || status == 401 </span><span class="cov8" title="1">{
                exec.To("set://?prop=body", response)
        }</span> else<span class="cov8" title="1"> {
                dataError := util.ParseJSON(response, new(models.ArrayDataError)).(*models.ArrayDataError)
                exec.To("set://?prop=body", strings.Replace(util.Stringify(dataError.Error[0]), "\\\"", "", -1))
        }</span>

        <span class="cov8" title="1">ch := exec.Choice()
        ch.When(Header("status").IsEqualTo("200"))
        ch.To("transform://?format=json", getResponsePefisa(), getAPIResponsePefisa(), tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))

        ch.When(Header("status").IsEqualTo("400"))
        ch.To("transform://?format=json", getResponseErrorPefisaArray(), getAPIResponsePefisa(), tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))

        ch.When(Header("status").IsEqualTo("401"))
        ch.To("transform://?format=json", getResponseErrorPefisa(), getAPIResponsePefisa(), tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))

        ch.Otherwise()
        ch.To("log://?type=response&amp;url="+pefisaURL, b.log).To("apierro://")

        switch t := exec.GetBody().(type) </span>{
        case *models.BoletoResponse:<span class="cov8" title="1">
                return *t, nil</span>
        case error:<span class="cov0" title="0">
                return models.BoletoResponse{}, t</span>
        }
        <span class="cov0" title="0">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}

func (b bankPefisa) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)

        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">if token, err := b.GetToken(boleto); err != nil </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, err
        }</span> else<span class="cov8" title="1"> {
                boleto.Authentication.AuthorizationToken = token
        }</span>

        <span class="cov8" title="1">return b.RegisterBoleto(boleto)</span>

}

func (b bankPefisa) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

//GetBankNumber retorna o codigo do banco
func (b bankPefisa) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Pefisa
}</span>

func (b bankPefisa) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "Pefisa"
}</span>

func (b bankPefisa) sendRequest(body string, token string) (string, int, error) <span class="cov8" title="1">{
        serviceURL := config.Get().URLPefisaRegister

        h := map[string]string{"Authorization": "Bearer " + token, "Content-Type": "application/json"}
        return util.Post(serviceURL, body, config.Get().TimeoutRegister, h)
}</span>

func pefisaBoletoTypes() map[string]string <span class="cov8" title="1">{
        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["DM"] = "1"   //Duplicata Mercantil
                m["DS"] = "2"   //Duplicata de serviços
                m["NP"] = "3"   //Nota promissória
                m["SE"] = "4"   //Seguro
                m["CH"] = "10"  //Cheque
                m["OUT"] = "99" //Outros
        }</span>)
        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "DM", "1"
        }</span>
        <span class="cov8" title="1">btm := pefisaBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "DM", "1"
        }</span>

        <span class="cov8" title="1">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package pefisa

const registerPefisa = `
## Authorization:Bearer {{.Authentication.AuthorizationToken}}
## Content-Type:application/json
{
    "idBeneficiario": {{.Agreement.AgreementNumber}},
    "carteira": {{.Agreement.Wallet}},
    "nossoNumero": "{{padLeft (toString .Title.OurNumber) "0" 10}}",
    "seuNumero": "{{truncate .Title.DocumentNumber 10}}",    
    "tipoTitulo": {{ .Title.BoletoTypeCode}},
    "valorTitulo": "{{toFloatStr .Title.AmountInCents}}",
    "dataDocumento": "{{enDate (today) "-"}}",
        "dataVencimento": "{{.Title.ExpireDate}}",
        "usoEmpresa": "A",
    "emitente": {
        "nome": "{{.Recipient.Name}}",
        {{if (eq .Recipient.Document.Type "CNPJ")}}
        "tipo": "J",        
        {{else}}
        "tipo": "F",
        {{end}}        
        "cnpjCpf": "{{extractNumbers .Recipient.Document.Number}}",
        "endereco": "{{truncate .Recipient.Address.Street 40}}",
        "cidade": "{{truncate .Recipient.Address.City 60}}",
        "cep": "{{truncate .Recipient.Address.ZipCode 8}}",
        "uf": "{{truncate .Recipient.Address.StateCode 2}}",
        "bairro": "{{truncate .Recipient.Address.District 65}}"
    },
    "pagador": {
        "nome": "{{truncate .Buyer.Name 40}}",
        {{if (eq .Buyer.Document.Type "CNPJ")}}
        "tipo": "J",
        {{else}}
        "tipo": "F",
        {{end}}        
        "cnpjCpf": "{{extractNumbers .Buyer.Document.Number}}",
        "endereco": "{{truncate .Buyer.Address.Street 40}}",
        "cidade": "{{truncate .Buyer.Address.City 20}}",
        "cep": "{{truncate (extractNumbers .Buyer.Address.ZipCode) 8}}",
        "uf": "{{truncate .Buyer.Address.StateCode 2}}",
        "bairro": "{{truncate .Buyer.Address.District 65}}"
        
    },
    "mensagens": [
        "{{truncate .Title.Instructions 80}}"
    ]
}
`

const pefisaGetTokenRequest = `
## Authorization:Basic {{base64 (concat .Authentication.Username ":" .Authentication.Password)}}
## Content-Type: application/x-www-form-urlencoded
grant_type=client_credentials`

const tokenResponse = `{        
        "access_token": "{{access_token}}"
}`

const tokenErrorResponse = `{    
        "error_description": "{{errorMessage}}"
}`

func getRequestToken() string <span class="cov8" title="1">{
        return pefisaGetTokenRequest
}</span>

func getTokenResponse() string <span class="cov8" title="1">{
        return tokenResponse
}</span>

func getTokenErrorResponse() string <span class="cov8" title="1">{
        return tokenErrorResponse
}</span>

func getRequestPefisa() string <span class="cov8" title="1">{
        return registerPefisa
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package pefisa

const registerBoletoResponsePefisa = `
{
    {{if (hasErrorTags . "errorCode") | (hasErrorTags . "errorMessage")}}
        "Errors": [
            {
                "Code": "{{trim .errorCode}}",
                "Message": "{{trim .errorMessage}}"
            }
        ]
    {{else}}
            "DigitableLine": "{{fmtDigitableLine (replace (replace .digitableLine "." "") " " "") }}",
            "BarCodeNumber": "{{trim .barCodeNumber}}"
    {{end}}
}
`

const boletoResponsePefisa = `
{
        "data": {
        "codigoBarras": "{{barCodeNumber}}",
                "linhaDigitavel": "{{digitableLine}}"
    }
}
`

const boletoResponseErrorPefisaArray = `
{
        "code": "{{errorCode}}",
        "message": "{{errorMessage}}"
}
`

const boletoResponseErrorPefisa = `
{
        "error": "{{errorCode}}",
        "error_description": "{{errorMessage}}"
}
`

func getResponsePefisa() string <span class="cov8" title="1">{
        return boletoResponsePefisa
}</span>

func getAPIResponsePefisa() string <span class="cov8" title="1">{
        return registerBoletoResponsePefisa
}</span>

func getResponseErrorPefisaArray() string <span class="cov8" title="1">{
        return boletoResponseErrorPefisaArray
}</span>

func getResponseErrorPefisa() string <span class="cov8" title="1">{
        return boletoResponseErrorPefisa
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package pefisa

import (
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func pefisaBoletoTypeValidate(b interface{}) error <span class="cov8" title="1">{
        bt := pefisaBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package santander

import (
        "github.com/mundipagg/boleto-api/models"
)

/*
Este erros segue exatamente a documentação do banco, por isso as mensagens em português
*/
var ticketResponseErrors = map[string]string{
        "-1": "Certificado não encontrado",
        "1":  "Erro, dados de entrada inválidos",
        "2":  "Erro interno de criptografia",
        "3":  "Erro, Ticket já utilizado anteriormente",
        "4":  "Erro, Ticket gerado para outro sistema",
        "5":  "Erro, Ticket expirado",
        "6":  "Erro interno (dados)",
        "7":  "Erro interno (timestamp)",
}

func checkError(code string) error <span class="cov8" title="1">{
        msg, exist := ticketResponseErrors[code]
        if !exist </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return models.NewFormatError(msg)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package santander

const registerBoleto = `
## SOAPAction:create
## Content-Type:text/xml

&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:impl="http://impl.webservice.ymb.app.bsbr.altec.com/"&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;impl:registraTitulo&gt;
         &lt;dto&gt;
            &lt;dtNsu&gt;{{today | brDateWithoutDelimiter }}&lt;/dtNsu&gt;
            &lt;estacao&gt;{{.Authentication.Username}}&lt;/estacao&gt;
            &lt;nsu&gt;{{santanderNSUPrefix (padLeft (toString .Title.OurNumber) "0" 13)}}&lt;/nsu&gt;
            &lt;ticket&gt;{{unscape .Authentication.AuthorizationToken}}&lt;/ticket&gt;
            &lt;tpAmbiente&gt;{{santanderEnv}}&lt;/tpAmbiente&gt;
         &lt;/dto&gt;
      &lt;/impl:registraTitulo&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

const registerSantanderResponse = `
&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
   &lt;soapenv:Body&gt;
      &lt;dlwmin:registraTituloResponse xmlns:dlwmin="http://impl.webservice.ymb.app.bsbr.altec.com/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
         &lt;return xmlns:ns2="http://impl.webservice.ymb.app.bsbr.altec.com/"&gt;
            &lt;descricaoErro&gt;{{message}}&lt;/descricaoErro&gt;
            &lt;situacao&gt;{{errorCode}}&lt;/situacao&gt;
            &lt;titulo&gt;
               &lt;cdBarra&gt;{{barcodeNumber}}&lt;/cdBarra&gt;
               &lt;linDig&gt;{{digitableLine}}&lt;/linDig&gt;
               &lt;nossoNumero&gt;{{ourNumber}}&lt;/nossoNumero&gt;
            &lt;/titulo&gt;
         &lt;/return&gt;
      &lt;/dlwmin:registraTituloResponse&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

const requestTicket = `

## SOAPAction:create
## Content-Type:text/xml

&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:impl="http://impl.webservice.dl.app.bsbr.altec.com/"&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;impl:create&gt;
         &lt;TicketRequest&gt;
            &lt;dados&gt;
                &lt;entry&gt;
                    &lt;key&gt;CONVENIO.COD-BANCO&lt;/key&gt;
                    &lt;value&gt;0033&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;CONVENIO.COD-CONVENIO&lt;/key&gt;
                    &lt;value&gt;{{.Agreement.AgreementNumber}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.TP-DOC&lt;/key&gt;
                    {{if eq .Buyer.Document.Type "CPF"}}
                                                 &lt;value&gt;01&lt;/value&gt;
                    {{else}}
                                                 &lt;value&gt;02&lt;/value&gt;
                                        {{end}}                    
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.NUM-DOC&lt;/key&gt;
                    &lt;value&gt;{{extractNumbers .Buyer.Document.Number}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.NOME&lt;/key&gt;
                    &lt;value&gt;{{clearString (truncate .Buyer.Name 40)}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.ENDER&lt;/key&gt;
                    &lt;value&gt;{{clearString (truncate .Buyer.Address.Street 40)}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.BAIRRO&lt;/key&gt;
                    &lt;value&gt;{{clearString (truncate .Buyer.Address.District 30)}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.CIDADE&lt;/key&gt;
                    &lt;value&gt;{{clearString (truncate .Buyer.Address.City 20)}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.UF&lt;/key&gt;
                    &lt;value&gt;{{clearString (truncate .Buyer.Address.StateCode 2)}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;PAGADOR.CEP&lt;/key&gt;
                    &lt;value&gt;{{truncate (extractNumbers .Buyer.Address.ZipCode) 8}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.NOSSO-NUMERO&lt;/key&gt;
                    &lt;value&gt;{{padLeft (toString .Title.OurNumber) "0" 13}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.SEU-NUMERO &lt;/key&gt;
                    &lt;value&gt;{{.Title.DocumentNumber}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.DT-VENCTO&lt;/key&gt;
                    &lt;value&gt;{{brDateWithoutDelimiter .Title.ExpireDateTime}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.DT-EMISSAO&lt;/key&gt;
                    &lt;value&gt;{{today | brDateWithoutDelimiter}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.ESPECIE&lt;/key&gt;
                    &lt;value&gt;{{ .Title.BoletoTypeCode}}&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.TP-DESC&lt;/key&gt;
                    &lt;value&gt;0&lt;/value&gt;
                &lt;/entry&gt;               
                &lt;entry&gt;
                    &lt;key&gt;TITULO.TP-PROTESTO&lt;/key&gt;
                    &lt;value&gt;0&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.QT-DIAS-PROTESTO&lt;/key&gt;
                    &lt;value&gt;0&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.QT-DIAS-BAIXA&lt;/key&gt;
                    &lt;value&gt;0&lt;/value&gt;
                &lt;/entry&gt;
                &lt;entry&gt;
                    &lt;key&gt;TITULO.VL-NOMINAL&lt;/key&gt;
                    &lt;value&gt;{{.Title.AmountInCents}}&lt;/value&gt;
                &lt;/entry&gt;                
                &lt;entry&gt;
                    &lt;key&gt;MENSAGEM&lt;/key&gt;
                    &lt;value&gt;{{clearString (truncate .Title.Instructions 100)}}&lt;/value&gt;
                &lt;/entry&gt;
            &lt;/dados&gt;
            &lt;expiracao&gt;600&lt;/expiracao&gt;
            &lt;sistema&gt;YMB&lt;/sistema&gt;
         &lt;/TicketRequest&gt;
      &lt;/impl:create&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

const ticketReponse = `
&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&gt;
    &lt;soapenv:Body&gt;
        &lt;dlwmin:createResponse xmlns:dlwmin="http://impl.webservice.dl.app.bsbr.altec.com/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
            &lt;TicketResponse&gt;
                &lt;retCode&gt;{{returnCode}}&lt;/retCode&gt;
                &lt;ticket&gt;{{ticket}}&lt;/ticket&gt;
            &lt;/TicketResponse&gt;
        &lt;/dlwmin:createResponse&gt;
    &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
`

func getResponseSantander() string <span class="cov8" title="1">{
        return registerSantanderResponse
}</span>

func getRequestSantander() string <span class="cov8" title="1">{
        return registerBoleto
}</span>

func getRequestTicket() string <span class="cov8" title="1">{
        return requestTicket
}</span>

func getTicketResponse() string <span class="cov8" title="1">{
        return ticketReponse
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package santander

var apiResponse = `
{
    {{if (eq .errorCode "20")}}
        "Errors": [
            {                    
                "Code": "{{trim .errorCode}}",
                "Message": "{{trim .message | formatSingleLine}}"
            }
        ]
    {{else}}
        "DigitableLine": "{{fmtDigitableLine (trim .digitableLine)}}",
        "BarcodeNumber": "{{trim .barcodeNumber}}"        
    {{end}}
}
`

func getAPIResponseSantander() string <span class="cov8" title="1">{
        return apiResponse
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package santander

import (
        "errors"
        "strconv"
        "strings"
        "sync"

        "net/http"

        . "github.com/PMoneda/flow"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"
        "github.com/mundipagg/boleto-api/metrics"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/tmpl"
        "github.com/mundipagg/boleto-api/util"
        "github.com/mundipagg/boleto-api/validations"
)

var o = &amp;sync.Once{}
var m map[string]string

type bankSantander struct {
        validate  *models.Validator
        log       *log.Log
        transport *http.Transport
}

//New Create a new Santander Integration Instance
func New() (bankSantander, error) <span class="cov8" title="1">{
        var err error
        b := bankSantander{
                validate: models.NewValidator(),
                log:      log.CreateLog(),
        }

        b.transport, err = util.BuildTLSTransport()
        if err != nil </span><span class="cov0" title="0">{
                return bankSantander{}, err
        }</span>

        <span class="cov8" title="1">b.validate.Push(validations.ValidateAmount)
        b.validate.Push(validations.ValidateExpireDate)
        b.validate.Push(validations.ValidateBuyerDocumentNumber)
        b.validate.Push(validations.ValidateRecipientDocumentNumber)
        b.validate.Push(santanderValidateAgreementNumber)
        b.validate.Push(satanderBoletoTypeValidate)

        return b, nil</span>
}

//Log retorna a referencia do log
func (b bankSantander) Log() *log.Log <span class="cov0" title="0">{
        return b.log
}</span>

func (b bankSantander) GetTicket(boleto *models.BoletoRequest) (string, error) <span class="cov8" title="1">{
        boleto.Title.OurNumber = calculateOurNumber(boleto)
        boleto.Title.BoletoType, boleto.Title.BoletoTypeCode = getBoletoType(boleto)
        pipe := NewFlow()
        url := config.Get().URLTicketSantander
        tlsURL := strings.Replace(config.Get().URLTicketSantander, "https", "tls", 1)
        pipe.From("message://?source=inline", boleto, getRequestTicket(), tmpl.GetFuncMaps())
        pipe.To("log://?type=request&amp;url="+url, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                pipe.To(tlsURL, b.transport, map[string]string{"timeout": config.Get().TimeoutToken})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("santander-get-ticket-boleto-time", duration.Seconds())
        pipe.To("log://?type=response&amp;url="+url, b.log)
        ch := pipe.Choice()
        ch.When(Header("status").IsEqualTo("200"))
        ch.To("transform://?format=xml", getTicketResponse(), `{{.returnCode}}:::{{.ticket}}`, tmpl.GetFuncMaps())
        ch.When(Header("status").IsEqualTo("403"))
        ch.To("set://?prop=body", errors.New("403 Forbidden"))
        ch.Otherwise()
        ch.To("log://?type=request&amp;url="+url, b.log).To("set://?prop=body", errors.New("integration error"))
        switch t := pipe.GetBody().(type) </span>{
        case string:<span class="cov8" title="1">
                items := pipe.GetBody().(string)
                parts := strings.Split(items, ":::")
                returnCode, ticket := parts[0], parts[1]
                return ticket, checkError(returnCode)</span>
        case error:<span class="cov0" title="0">
                return "", t</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

func (b bankSantander) RegisterBoleto(input *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        serviceURL := config.Get().URLRegisterBoletoSantander
        fromResponse := getResponseSantander()
        toAPI := getAPIResponseSantander()
        inputTemplate := getRequestSantander()
        santanderURL := strings.Replace(serviceURL, "https", "tls", 1)

        exec := NewFlow().From("message://?source=inline", input, inputTemplate, tmpl.GetFuncMaps())
        exec.To("log://?type=request&amp;url="+serviceURL, b.log)
        duration := util.Duration(func() </span><span class="cov8" title="1">{
                exec.To(santanderURL, b.transport, map[string]string{"method": "POST", "insecureSkipVerify": "true", "timeout": config.Get().TimeoutRegister})
        }</span>)
        <span class="cov8" title="1">metrics.PushTimingMetric("santander-register-boleto-time", duration.Seconds())
        exec.To("log://?type=response&amp;url="+serviceURL, b.log)
        ch := exec.Choice()
        ch.When(Header("status").IsEqualTo("200"))
        ch.To("transform://?format=xml", fromResponse, toAPI, tmpl.GetFuncMaps())
        ch.To("unmarshall://?format=json", new(models.BoletoResponse))
        ch.Otherwise()
        ch.To("log://?type=response&amp;url="+serviceURL, b.log).To("apierro://")
        switch t := exec.GetBody().(type) </span>{
        case *models.BoletoResponse:<span class="cov8" title="1">
                return *t, nil</span>
        case error:<span class="cov0" title="0">
                return models.BoletoResponse{}, t</span>
        }
        <span class="cov0" title="0">return models.BoletoResponse{}, models.NewInternalServerError("MP500", "Internal error")</span>
}
func (b bankSantander) ProcessBoleto(boleto *models.BoletoRequest) (models.BoletoResponse, error) <span class="cov8" title="1">{
        errs := b.ValidateBoleto(boleto)
        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, nil
        }</span>
        <span class="cov8" title="1">if ticket, err := b.GetTicket(boleto); err != nil </span><span class="cov0" title="0">{
                return models.BoletoResponse{Errors: errs}, err
        }</span> else<span class="cov8" title="1"> {
                boleto.Authentication.AuthorizationToken = ticket
        }</span>
        <span class="cov8" title="1">return b.RegisterBoleto(boleto)</span>
}

func (b bankSantander) ValidateBoleto(boleto *models.BoletoRequest) models.Errors <span class="cov8" title="1">{
        return models.Errors(b.validate.Assert(boleto))
}</span>

//GetBankNumber retorna o codigo do banco
func (b bankSantander) GetBankNumber() models.BankNumber <span class="cov0" title="0">{
        return models.Santander
}</span>

func calculateOurNumber(boleto *models.BoletoRequest) uint <span class="cov8" title="1">{
        ourNumberWithDigit := strconv.Itoa(int(boleto.Title.OurNumber)) + util.OurNumberDv(strconv.Itoa(int(boleto.Title.OurNumber)), util.MOD11)
        value, _ := strconv.Atoi(ourNumberWithDigit)
        return uint(value)
}</span>

func (b bankSantander) GetBankNameIntegration() string <span class="cov0" title="0">{
        return "Santander"
}</span>

func santanderBoletoTypes() map[string]string <span class="cov8" title="1">{
        o.Do(func() </span><span class="cov8" title="1">{
                m = make(map[string]string)

                m["DM"] = "02"  //Duplicata Mercantil
                m["DS"] = "04"  //Duplicata de serviço
                m["NP"] = "12"  //Nota promissória
                m["RC"] = "17"  //Recibo
                m["BDP"] = "32" //Boleto de proposta
                m["CH"] = "97"  //Cheque
                m["OUT"] = "99" //Outros
        }</span>)

        <span class="cov8" title="1">return m</span>
}

func getBoletoType(boleto *models.BoletoRequest) (bt string, btc string) <span class="cov8" title="1">{
        if len(boleto.Title.BoletoType) &lt; 1 </span><span class="cov8" title="1">{
                return "DM", "02"
        }</span>

        <span class="cov8" title="1">btm := santanderBoletoTypes()

        if btm[strings.ToUpper(boleto.Title.BoletoType)] == "" </span><span class="cov8" title="1">{
                return "DM", "02"
        }</span>

        <span class="cov8" title="1">return boleto.Title.BoletoType, btm[strings.ToUpper(boleto.Title.BoletoType)]</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package santander

import (
        "fmt"

        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/validations"
)

func santanderValidateAgreementNumber(b interface{}) error <span class="cov8" title="1">{
        switch t := b.(type) </span>{
        case *models.BoletoRequest:<span class="cov8" title="1">
                if t.Agreement.AgreementNumber == 0 </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", fmt.Sprintf("O código do convênio deve ser preenchido"))
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}

func satanderBoletoTypeValidate(b interface{}) error <span class="cov8" title="1">{
        bt := santanderBoletoTypes()

        switch t := b.(type) </span>{

        case *models.BoletoRequest:<span class="cov8" title="1">
                if len(t.Title.BoletoType) &gt; 0 &amp;&amp; bt[t.Title.BoletoType] == "" </span><span class="cov0" title="0">{
                        return models.NewErrorResponse("MP400", "espécie de boleto informada não existente")
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return validations.InvalidType(t)</span>
        }
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package tmpl

import (
        "bytes"
        "html"
        "html/template"
        "regexp"
        "strings"
        "time"

        "gopkg.in/mgo.v2/bson"

        "strconv"

        "fmt"

        "github.com/kennygrant/sanitize"
        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/models"
        "github.com/mundipagg/boleto-api/util"
)

var funcMap = template.FuncMap{
        "today":                             today,
        "todayCiti":                         todayCiti,
        "brdate":                            brDate,
        "replace":                           replace,
        "docType":                           docType,
        "trim":                              trim,
        "padLeft":                           padLeft,
        "clearString":                       clearString,
        "toString":                          toString,
        "toString64":                        toString64,
        "fmtDigitableLine":                  fmtDigitableLine,
        "fmtCNPJ":                           fmtCNPJ,
        "fmtCPF":                            fmtCPF,
        "fmtDoc":                            fmtDoc,
        "truncate":                          truncateString,
        "fmtNumber":                         fmtNumber,
        "joinSpace":                         joinSpace,
        "brDateWithoutDelimiter":            brDateWithoutDelimiter,
        "enDateWithoutDelimiter":            enDateWithoutDelimiter,
        "fullDate":                          fulldate,
        "enDate":                            enDate,
        "hasErrorTags":                      hasErrorTags,
        "toFloatStr":                        toFloatStr,
        "concat":                            concat,
        "base64":                            base64,
        "unscape":                           unscape,
        "unescapeHtmlString":                unescapeHtmlString,
        "trimLeft":                          trimLeft,
        "santanderNSUPrefix":                santanderNSUPrefix,
        "santanderEnv":                      santanderEnv,
        "formatSingleLine":                  formatSingleLine,
        "diff":                              diff,
        "mod11dv":                           calculateOurNumberMod11,
        "mod10ItauDv":                       mod10Itau,
        "printIfNotProduction":              printIfNotProduction,
        "itauEnv":                           itauEnv,
        "caixaEnv":                          caixaEnv,
        "extractNumbers":                    extractNumbers,
        "splitValues":                       splitValues,
        "brDateDelimiter":                   brDateDelimiter,
        "brDateDelimiterTime":               brDateDelimiterTime,
        "toString16":                        toString16,
        "mod11BradescoShopFacilDv":          mod11BradescoShopFacilDv,
        "bsonMongoToString":                 bsonMongoToString,
        "truncateManyFields":                truncateManyFields,
        "escapeStringOnJson":                escapeStringOnJson,
        "removeSpecialCharacter":            removeSpecialCharacter,
        "sanitizeCitibankSpecialCharacteres": sanitizeCitibankSpecialCharacteres,
}

func GetFuncMaps() template.FuncMap <span class="cov0" title="0">{
        return funcMap
}</span>

func santanderNSUPrefix(number string) string <span class="cov0" title="0">{
        if config.Get().SantanderEnv == "T" </span><span class="cov0" title="0">{
                return "TST" + number
        }</span>
        <span class="cov0" title="0">return number</span>
}

func santanderEnv() string <span class="cov0" title="0">{
        return config.Get().SantanderEnv
}</span>

func diff(a string, b string) bool <span class="cov0" title="0">{
        return a != b
}</span>

func formatSingleLine(s string) string <span class="cov0" title="0">{
        s1 := strings.Replace(s, "\r", "", -1)
        return strings.Replace(s1, "\n", "; ", -1)
}</span>

func padLeft(value, char string, total uint) string <span class="cov8" title="1">{
        s := util.PadLeft(value, char, total)
        return s
}</span>
func unscape(s string) template.HTML <span class="cov0" title="0">{
        return template.HTML(s)
}</span>

func sanitizeHtmlString(s string) string <span class="cov8" title="1">{
        str := html.UnescapeString(s)
        return sanitize.HTML(str)
}</span>

func unescapeHtmlString(s string) template.HTML <span class="cov8" title="1">{
        c := sanitizeHtmlString(s)
        return template.HTML(html.UnescapeString(c))
}</span>

func trimLeft(s string, caract string) string <span class="cov0" title="0">{
        return strings.TrimLeft(s, caract)
}</span>

func truncateString(str string, num int) string <span class="cov8" title="1">{
        bnoden := removeSpecialCharacter(str)

        if len(bnoden) &gt; num </span><span class="cov8" title="1">{
                bnoden = str[0:num]
        }</span>
        //Support extended ASCII
        <span class="cov8" title="1">return string([]rune(bnoden))</span>
}

func clearString(str string) string <span class="cov8" title="1">{
        s := sanitize.Accents(str)
        var buffer bytes.Buffer
        for _, ch := range s </span><span class="cov8" title="1">{
                if ch &lt;= 122 &amp;&amp; ch &gt;= 32 </span><span class="cov8" title="1">{
                        buffer.WriteString(string(ch))
                }</span>
        }
        <span class="cov8" title="1">return buffer.String()</span>
}

func joinSpace(str ...string) string <span class="cov8" title="1">{
        return strings.Join(str, " ")
}</span>

func hasErrorTags(mapValues map[string]string, errorTags ...string) bool <span class="cov0" title="0">{
        hasError := false
        for _, v := range errorTags </span><span class="cov0" title="0">{
                if value, exist := mapValues[v]; exist &amp;&amp; strings.Trim(value, " ") != "" </span><span class="cov0" title="0">{
                        hasError = true
                        break</span>
                }
        }
        <span class="cov0" title="0">return hasError</span>
}

func fmtNumber(n uint64) string <span class="cov8" title="1">{
        real := n / 100
        cents := n % 100
        return fmt.Sprintf("%d,%02d", real, cents)
}</span>

func printIfNotProduction(obj string) string <span class="cov0" title="0">{
        if config.IsNotProduction() </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s", obj)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func toFloatStr(n uint64) string <span class="cov8" title="1">{
        real := n / 100
        cents := n % 100
        return fmt.Sprintf("%d.%02d", real, cents)
}</span>

func fmtDoc(doc models.Document) string <span class="cov8" title="1">{
        if e := doc.ValidateCPF(); e == nil </span><span class="cov8" title="1">{
                return fmtCPF(doc.Number)
        }</span>
        <span class="cov8" title="1">return fmtCNPJ(doc.Number)</span>
}

func toString(number uint) string <span class="cov8" title="1">{
        return strconv.FormatInt(int64(number), 10)
}</span>

func toString16(number uint16) string <span class="cov0" title="0">{
        return strconv.FormatInt(int64(number), 10)
}</span>

func toString64(number uint64) string <span class="cov0" title="0">{
        return strconv.FormatInt(int64(number), 10)
}</span>

func today() time.Time <span class="cov0" title="0">{
        return util.BrNow()
}</span>

func todayCiti() time.Time <span class="cov0" title="0">{
        return util.NycNow()
}</span>

func fulldate(t time.Time) string <span class="cov0" title="0">{
        return t.Format("20060102150405")
}</span>

func brDate(d time.Time) string <span class="cov0" title="0">{
        return d.Format("02/01/2006")
}</span>

func enDate(d time.Time, del string) string <span class="cov0" title="0">{
        return d.Format("2006" + del + "01" + del + "02")
}</span>

func brDateWithoutDelimiter(d time.Time) string <span class="cov0" title="0">{
        return d.Format("02012006")
}</span>

func enDateWithoutDelimiter(d time.Time) string <span class="cov0" title="0">{
        return d.Format("20060102")
}</span>

func replace(str, old, new string) string <span class="cov0" title="0">{
        return strings.Replace(str, old, new, -1)
}</span>

func docType(s models.Document) int <span class="cov8" title="1">{
        if s.IsCPF() </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return 2</span>
}

func trim(s string) string <span class="cov8" title="1">{
        return strings.TrimSpace(s)
}</span>
func fmtDigitableLine(s string) string <span class="cov8" title="1">{
        buf := bytes.Buffer{}
        for idx, c := range s </span><span class="cov8" title="1">{
                if idx == 5 || idx == 15 || idx == 26 </span><span class="cov8" title="1">{
                        buf.WriteString(".")
                }</span>
                <span class="cov8" title="1">if idx == 10 || idx == 21 || idx == 32 || idx == 33 </span><span class="cov8" title="1">{
                        buf.WriteString(" ")
                }</span>
                <span class="cov8" title="1">buf.WriteByte(byte(c))</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}

func fmtCNPJ(s string) string <span class="cov8" title="1">{
        buf := bytes.Buffer{}
        for idx, c := range s </span><span class="cov8" title="1">{
                if idx == 2 || idx == 5 </span><span class="cov8" title="1">{
                        buf.WriteString(".")
                }</span>
                <span class="cov8" title="1">if idx == 8 </span><span class="cov8" title="1">{
                        buf.WriteString("/")
                }</span>
                <span class="cov8" title="1">if idx == 12 </span><span class="cov8" title="1">{
                        buf.WriteString("-")
                }</span>
                <span class="cov8" title="1">buf.WriteRune(c)</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}

func fmtCPF(s string) string <span class="cov8" title="1">{
        buf := bytes.Buffer{}
        for idx, c := range s </span><span class="cov8" title="1">{
                if idx == 3 || idx == 6 </span><span class="cov8" title="1">{
                        buf.WriteString(".")
                }</span>
                <span class="cov8" title="1">if idx == 9 </span><span class="cov8" title="1">{
                        buf.WriteString("-")
                }</span>
                <span class="cov8" title="1">buf.WriteRune(c)</span>
        }
        <span class="cov8" title="1">return buf.String()</span>
}

func concat(s ...string) string <span class="cov0" title="0">{
        buf := bytes.Buffer{}
        for _, item := range s </span><span class="cov0" title="0">{
                buf.WriteString(item)
        }</span>
        <span class="cov0" title="0">return buf.String()</span>
}

func base64(s string) string <span class="cov0" title="0">{
        return util.Base64(s)
}</span>

func calculateOurNumberMod11(number uint, onlyDigit bool) uint <span class="cov8" title="1">{

        ourNumberDigit := util.OurNumberDv(strconv.Itoa(int(number)), util.MOD11)

        if onlyDigit </span><span class="cov8" title="1">{
                value, _ := strconv.Atoi(ourNumberDigit)
                return uint(value)
        }</span>

        <span class="cov8" title="1">ourNumberWithDigit := strconv.Itoa(int(number)) + ourNumberDigit
        value, _ := strconv.Atoi(ourNumberWithDigit)
        return uint(value)</span>
}

func mod10Itau(number string, agency string, account string, wallet uint16) string <span class="cov0" title="0">{

        var buffer bytes.Buffer

        if wallet == 126 || wallet == 131 || wallet == 146 || wallet == 168 </span><span class="cov0" title="0">{

                buffer.WriteString(strconv.FormatUint(uint64(wallet), 10))
                buffer.WriteString(number)

                return util.OurNumberDv(buffer.String(), util.MOD10)
        }</span> else<span class="cov0" title="0"> {
                buffer.WriteString(agency)
                buffer.WriteString(account)
                buffer.WriteString(strconv.FormatUint(uint64(wallet), 10))
                buffer.WriteString(number)
                return util.OurNumberDv(buffer.String(), util.MOD10)
        }</span>
}

func itauEnv() string <span class="cov0" title="0">{
        return config.Get().ItauEnv
}</span>

func caixaEnv() string <span class="cov0" title="0">{
        return config.Get().CaixaEnv
}</span>

func extractNumbers(value string) string <span class="cov8" title="1">{
        re := regexp.MustCompile("(\\D+)")
        sanitizeValue := re.ReplaceAllString(string(value), "")
        return sanitizeValue
}</span>

func splitValues(value string, init int, end int) string <span class="cov0" title="0">{
        return value[init:end]
}</span>

func brDateDelimiter(date string, del string) string <span class="cov0" title="0">{
        layout := "2006-01-02"
        d, err := time.Parse(layout, date)
        if err != nil </span><span class="cov0" title="0">{
                return date
        }</span>

        <span class="cov0" title="0">return d.Format("02" + del + "01" + del + "2006")</span>
}

func brDateDelimiterTime(date time.Time, del string) string <span class="cov0" title="0">{
        layout := "2006-01-02 00:00:00 +0000 UTC"

        d, err := time.Parse(layout, date.String())

        if err != nil </span><span class="cov0" title="0">{
                return date.String()
        }</span>

        <span class="cov0" title="0">return d.Format("02" + del + "01" + del + "2006")</span>
}

func mod11BradescoShopFacilDv(number string, wallet string) string <span class="cov8" title="1">{
        var buffer bytes.Buffer
        buffer.WriteString(wallet)
        buffer.WriteString(number)
        return util.OurNumberDv(buffer.String(), util.MOD11, 7)
}</span>

func bsonMongoToString(bsonId bson.ObjectId) string <span class="cov0" title="0">{
        idBson, _ := bsonId.MarshalText()
        return string(idBson)
}</span>

func truncateManyFields(num int, values ...string) string <span class="cov0" title="0">{
        buf := bytes.Buffer{}
        for _, item := range values </span><span class="cov0" title="0">{
                buf.WriteString(" " + item)
        }</span>
        <span class="cov0" title="0">str := strings.Trim(buf.String(), " ")
        return truncateString(str, num)</span>
}

func escapeStringOnJson(field string) string <span class="cov8" title="1">{
        field = strings.Replace(field, "\b", "", -1)
        return regexp.MustCompile(`[\t\f\r\\]`).ReplaceAllString(field, "")
}</span>

func removeSpecialCharacter(str string) string <span class="cov8" title="1">{
        return regexp.MustCompile("[^a-zA-Z0-9ÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕáéíóúàèìòùâêîôûãõç,.\\-\\s]+").ReplaceAllString(str, "")
}</span>

func sanitizeCitibankSpecialCharacteres(str string, num int) string <span class="cov8" title="1">{
        str = regexp.MustCompile("[^a-zA-Z0-9.;@\\-\\/\\s]+").ReplaceAllString(clearString(str), "")
        
        if len(str) &gt; num </span><span class="cov8" title="1">{
                str = str[0:num]
        }</span>

        <span class="cov8" title="1">return str</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package tmpl

import (
        "bytes"
        "html/template"
)

// Builder e o padrao que vai transformar mensagens de entrada em mensagens de saida para os bancos
type Builder interface {
        From(interface{}) Builder
        To(string) Builder
        Transform(...string) (string, error)
        XML() Builder
}

type msgBuilder struct {
        from     interface{}
        template string
        head     string
}

func (b msgBuilder) From(obj interface{}) Builder <span class="cov0" title="0">{
        b.from = obj
        return b
}</span>

func (b msgBuilder) To(template string) Builder <span class="cov0" title="0">{
        b.template = template
        return b
}</span>
func (b msgBuilder) XML() Builder <span class="cov0" title="0">{
        b.head = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;`
        return b
}</span>

func (b msgBuilder) Transform(partials ...string) (string, error) <span class="cov0" title="0">{
        buf := bytes.NewBuffer(nil)
        t := template.Must(template.New("transform").Funcs(funcMap).Parse(b.template))
        for _, p := range partials </span><span class="cov0" title="0">{
                t, _ = t.Parse(p)
        }</span>
        <span class="cov0" title="0">err := t.ExecuteTemplate(buf, "transform", b.from)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if b.head != "" </span><span class="cov0" title="0">{
                h := b.head
                b.head = ""
                return h + buf.String(), nil
        }</span>

        <span class="cov0" title="0">return buf.String(), nil</span>
}

// New cria um novo builder
func New() Builder <span class="cov0" title="0">{
        return msgBuilder{}
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package util

import (
        "fmt"

        "github.com/mundipagg/boleto-api/config"
        "github.com/mundipagg/boleto-api/log"

        "errors"
        "net/http"
        "strings"

        "github.com/PMoneda/flow"
)

// LogConector é um connector flow para utilizar as rotinas de log
func LogConector(e *flow.ExchangeMessage, u flow.URI, params ...interface{}) error <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Println(r)
                }</span>
        }()
        <span class="cov0" title="0">var b string
        switch t := e.GetBody().(type) </span>{
        case string:<span class="cov0" title="0">
                if t == "" </span><span class="cov0" title="0">{
                        b = "Nenhum retorno do serviço"
                }</span> else<span class="cov0" title="0"> {
                        b = t
                }</span>
        case error:<span class="cov0" title="0">
                b = t.Error()</span>
        default:<span class="cov0" title="0">
                b = fmt.Sprintln(t)</span>
        }
        <span class="cov0" title="0">if len(params) &gt; 0 </span><span class="cov0" title="0">{
                l := params[0].(*log.Log)
                if u.GetOption("type") == "request" </span><span class="cov0" title="0">{
                        l.Request(b, u.GetOption("url"), e.GetHeaderMap())
                }</span>
                <span class="cov0" title="0">if u.GetOption("type") == "response" </span><span class="cov0" title="0">{
                        l.Response(b, u.GetOption("url"))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

//TlsConector is a connector to send https request client certificate Params[0] *http.Transport (http.Transport configuration with certificate files config)
func TlsConector(e *flow.ExchangeMessage, u flow.URI, params ...interface{}) error <span class="cov0" title="0">{
        var b string
        switch t := e.GetBody().(type) </span>{
        case string:<span class="cov0" title="0">
                if t == "" </span><span class="cov0" title="0">{
                        b = "Nenhum retorno do serviço"
                }</span> else<span class="cov0" title="0"> {
                        b = t
                }</span>
        case error:<span class="cov0" title="0">
                b = t.Error()</span>
        default:<span class="cov0" title="0">
                b = fmt.Sprintln(t)</span>
        }
        <span class="cov0" title="0">if len(params) &gt; 0 </span><span class="cov0" title="0">{

                var timeout = params[1].(map[string]string)["timeout"]

                switch t := params[0].(type) </span>{
                case *http.Transport:<span class="cov0" title="0">
                        var url string
                        var response string
                        var status int
                        var err error

                        if config.Get().MockMode </span><span class="cov0" title="0">{
                                url = strings.Replace(u.GetRaw(), "tls", "http", 1)
                                response, status, err = Post(url, b, timeout, e.GetHeaderMap())
                        }</span> else<span class="cov0" title="0"> {
                                url = strings.Replace(u.GetRaw(), "tls", "https", 1)
                                response, status, err = PostTLS(url, b, timeout, e.GetHeaderMap(), t)
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                e.SetHeader("error", err.Error())
                                e.SetBody(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">e.SetHeader("status", fmt.Sprintf("%d", status))
                        e.SetBody(response)</span>
                default:<span class="cov0" title="0">
                        return errors.New("invalid data type")</span>
                }
        } else<span class="cov0" title="0"> {
                return errors.New("Http Transport is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package util

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "fmt"
        "io"
)

const _key = "2131231231231234"

//Encrypt encripta texto baseado na documentação do GO
func Encrypt(s string) string <span class="cov8" title="1">{
        key := []byte(_key)
        plaintext := []byte(s)
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">ciphertext := make([]byte, aes.BlockSize+len(plaintext))
        iv := ciphertext[:aes.BlockSize]
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">stream := cipher.NewCFBEncrypter(block, iv)
        stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
        // convert to base64
        return base64.URLEncoding.EncodeToString(ciphertext)</span>
}

//Decrypt decripta string encriptada
func Decrypt(s string) string <span class="cov8" title="1">{
        ciphertext, _ := base64.URLEncoding.DecodeString(s)

        block, err := aes.NewCipher([]byte(_key))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // The IV needs to be unique, but not secure. Therefore it's common to
        // include it at the beginning of the ciphertext.
        <span class="cov8" title="1">if len(ciphertext) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">iv := ciphertext[:aes.BlockSize]
        ciphertext = ciphertext[aes.BlockSize:]

        stream := cipher.NewCFBDecrypter(block, iv)

        // XORKeyStream can work in-place if the two arguments are the same.
        stream.XORKeyStream(ciphertext, ciphertext)

        return fmt.Sprintf("%s", ciphertext)</span>
}

//Base64 converte um string para base64
func Base64(s string) string <span class="cov8" title="1">{
        sEnc := base64.StdEncoding.EncodeToString([]byte(s))
        return sEnc
}</span>

//Base64Decode converte uma string base64 para uma string normal
func Base64Decode(s string) string <span class="cov8" title="1">{
        sDec, _ := base64.StdEncoding.DecodeString(s)
        return string(sDec)
}</span>

//Sha256 converts string to hash sha256. Encode default: Base64
func Sha256(s, e string) string <span class="cov0" title="0">{
        var sEnc string

        h := sha256.New()
        h.Write([]byte(s))

        switch e </span>{
        case "hex":<span class="cov0" title="0">
                sEnc = hex.EncodeToString(h.Sum(nil))</span>
        default:<span class="cov0" title="0">
                sEnc = base64.StdEncoding.EncodeToString(h.Sum(nil))</span>
        }
        <span class="cov0" title="0">return sEnc</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package util

func CheckErrorRobot(err error) bool <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package util

import (
        "io/ioutil"

        "github.com/golang/freetype/truetype"
        "github.com/mundipagg/boleto-api/log"

        "github.com/golang/freetype"
)

type font struct {
        FtFont *truetype.Font
}

var fnt font

func GetFont() font <span class="cov0" title="0">{

        if (font{}) == fnt </span><span class="cov0" title="0">{
                fontBytes, err := ioutil.ReadFile("./boleto/Arial.ttf")
                if err != nil </span><span class="cov0" title="0">{
                        l := log.CreateLog()
                        l.Fatal(err.Error(), " An error has occurred load font")
                }</span>

                <span class="cov0" title="0">f, err := freetype.ParseFont(fontBytes)
                if err != nil </span><span class="cov0" title="0">{
                        l := log.CreateLog()
                        l.Fatal(err.Error(), " An error has occurred load font")
                }</span>

                <span class="cov0" title="0">fnt = font{
                        FtFont: f,
                }</span>
        }

        <span class="cov0" title="0">return fnt</span>
}</pre>
		
		<pre class="file" id="file56" style="display: none">package util

import (
        "context"
        "crypto"
        "crypto/tls"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "errors"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/mundipagg/boleto-api/certificate"

        s "github.com/fullsailor/pkcs7"
        "github.com/mundipagg/boleto-api/config"
)

var defaultDialer = &amp;net.Dialer{Timeout: 16 * time.Second, KeepAlive: 16 * time.Second}

var (
        client            *http.Client
        onceDefaultClient = &amp;sync.Once{}
        onceTransport     = &amp;sync.Once{}
        icpCert           certificate.ICPCertificate
        transport         *http.Transport
)

// DefaultHTTPClient retorna um cliente http configurado para dar um skip na validação do certificado digital
func DefaultHTTPClient() *http.Client <span class="cov0" title="0">{
        onceDefaultClient.Do(func() </span><span class="cov0" title="0">{
                client = &amp;http.Client{
                        Transport: &amp;http.Transport{
                                Dial:                defaultDialer.Dial,
                                TLSHandshakeTimeout: 16 * time.Second,
                                TLSClientConfig: &amp;tls.Config{
                                        InsecureSkipVerify: true,
                                },
                        },
                }
        }</span>)
        <span class="cov0" title="0">return client</span>
}

//Post faz um requisição POST para uma URL e retorna o response, status e erro
func Post(url, body, timeout string, header map[string]string) (string, int, error) <span class="cov0" title="0">{
        return doRequest("POST", url, body, timeout, header)
}</span>

//Get faz um requisição GET para uma URL e retorna o response, status e erro
func Get(url, body, timeout string, header map[string]string) (string, int, error) <span class="cov0" title="0">{
        return doRequest("GET", url, body, timeout, header)
}</span>

func doRequest(method, url, body, timeout string, header map[string]string) (string, int, error) <span class="cov0" title="0">{
        t := GetDurationTimeoutRequest(timeout) * time.Second

        ctx, cls := context.WithTimeout(context.Background(), t)
        defer cls()

        client := DefaultHTTPClient()

        message := strings.NewReader(body)

        req, err := http.NewRequestWithContext(ctx, method, url, message)
        if err != nil </span><span class="cov0" title="0">{
                return "", http.StatusInternalServerError, err
        }</span>
        <span class="cov0" title="0">if header != nil </span><span class="cov0" title="0">{
                for k, v := range header </span><span class="cov0" title="0">{
                        req.Header.Add(k, v)
                }</span>
        }
        <span class="cov0" title="0">resp, errResp := client.Do(req)
        if errResp != nil </span><span class="cov0" title="0">{
                return "", 0, errResp
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        data, errResponse := ioutil.ReadAll(resp.Body)
        if errResponse != nil </span><span class="cov0" title="0">{
                return "", resp.StatusCode, errResponse
        }</span>
        <span class="cov0" title="0">sData := string(data)
        return sData, resp.StatusCode, nil</span>
}

// BuildTLSTransport creates a TLS Client Transport from crt, ca and key files
func BuildTLSTransport() (*http.Transport, error) <span class="cov0" title="0">{

        if (config.Get().MockMode)</span><span class="cov0" title="0">{
                return nil, nil;
        }</span>

        <span class="cov0" title="0">var errF error
        onceTransport.Do(func() </span><span class="cov0" title="0">{

                ssl, err := certificate.GetCertificateFromStore(config.Get().CertificateSSLName)
                if err != nil </span><span class="cov0" title="0">{
                        errF = err
                        return
                }</span>

                <span class="cov0" title="0">cert, err := tls.X509KeyPair(ssl.(certificate.SSLCertificate).PemData, ssl.(certificate.SSLCertificate).PemData)
                if err != nil </span><span class="cov0" title="0">{
                        errF = err
                        return
                }</span>

                <span class="cov0" title="0">transport = &amp;http.Transport{
                        Dial:                defaultDialer.Dial,
                        TLSHandshakeTimeout: 16 * time.Second,
                        TLSClientConfig: &amp;tls.Config{
                                Certificates:       []tls.Certificate{cert},
                                InsecureSkipVerify: true,
                        },
                }
                return</span>
        })
        <span class="cov0" title="0">return transport, errF</span>
}

//Sign request
func SignRequest(request string) (string, error) <span class="cov0" title="0">{

        if icpCert == (certificate.ICPCertificate{}) </span><span class="cov0" title="0">{
                icp, err := certificate.GetCertificateFromStore(config.Get().CertificateICPName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">icpCert = icp.(certificate.ICPCertificate)</span>
        }

        <span class="cov0" title="0">signedData, err := s.NewSignedData([]byte(request))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if err := signedData.AddSigner(icpCert.Certificate, icpCert.RsaPrivateKey, s.SignerInfoConfig{}); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">detachedSignature, err := signedData.Finish()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">signedRequest := base64.StdEncoding.EncodeToString(detachedSignature)

        return signedRequest, nil</span>
}

//Read privatekey and parse to PKCS#1
func parsePrivateKey() (crypto.PrivateKey, error) <span class="cov0" title="0">{

        pkeyBytes, err := ioutil.ReadFile(config.Get().CertICP_PathPkey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">block, _ := pem.Decode(pkeyBytes)
        if block == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Key Not Found")
        }</span>

        <span class="cov0" title="0">switch block.Type </span>{
        case "RSA PRIVATE KEY":<span class="cov0" title="0">
                rsa, err := x509.ParsePKCS1PrivateKey(block.Bytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return rsa, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("SSH: Unsupported key type %q", block.Type)</span>
        }

}

///Read chainCertificates and adapter to x509.Certificate
func parseChainCertificates() (*x509.Certificate, error) <span class="cov0" title="0">{

        chainCertsBytes, err := ioutil.ReadFile(config.Get().CertICP_PathChainCertificates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">block, _ := pem.Decode(chainCertsBytes)
        if block == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Key Not Found")
        }</span>

        <span class="cov0" title="0">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cert, nil</span>
}

func doRequestTLS(method, url, body, timeout string, header map[string]string, transport *http.Transport) (string, int, error) <span class="cov0" title="0">{
        tlsClient := &amp;http.Client{}
        tlsClient.Transport = transport
        tlsClient.Timeout = GetDurationTimeoutRequest(timeout) * time.Second
        b := strings.NewReader(body)
        req, err := http.NewRequest(method, url, b)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">if header != nil </span><span class="cov0" title="0">{
                for k, v := range header </span><span class="cov0" title="0">{
                        req.Header.Add(k, v)
                }</span>
        }
        <span class="cov0" title="0">resp, err := tlsClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        // Dump response
        data, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        <span class="cov0" title="0">sData := string(data)
        return sData, resp.StatusCode, nil</span>
}

func PostTLS(url, body, timeout string, header map[string]string, transport *http.Transport) (string, int, error) <span class="cov0" title="0">{
        return doRequestTLS("POST", url, body, timeout, header, transport)
}</span>

//HeaderToMap converte um http Header para um dicionário string -&gt; string
func HeaderToMap(h http.Header) map[string]string <span class="cov0" title="0">{
        m := make(map[string]string)
        for k, v := range h </span><span class="cov0" title="0">{
                m[k] = v[0]
        }</span>
        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package util

import (
        "encoding/json"
)

//FromJSON converts string json to object
func FromJSON(jsonStr string, obj interface{}) error <span class="cov8" title="1">{
        return json.Unmarshal([]byte(jsonStr), obj)
}</span>

//ToJSON converts object to json string
func ToJSON(obj interface{}) string <span class="cov8" title="1">{
        s, _ := json.Marshal(obj)
        return string(s)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package util

import (
        "strconv"
)

type ModFunc int

const (
        MOD10 ModFunc = 1 + iota
        MOD11
)

//mod11 calculate Mod11 DV from string
func mod11(valueSequence string, baseNum ...int) int <span class="cov0" title="0">{
        base := 9
        digit := 0
        sum := 0
        weight := 2

        var values []int

        if baseNum != nil </span><span class="cov0" title="0">{
                base = baseNum[0]
        }</span>

        <span class="cov0" title="0">for _, r := range valueSequence </span><span class="cov0" title="0">{
                c := string(r)
                n, _ := strconv.Atoi(c)
                values = append(values, n)
        }</span>
        <span class="cov0" title="0">for i := len(values) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                sum += values[i] * weight

                if weight &lt; base </span><span class="cov0" title="0">{
                        weight = weight + 1
                }</span> else<span class="cov0" title="0"> {
                        weight = 2
                }</span>
        }
        <span class="cov0" title="0">digit = 11 - (sum % 11)
        return digit</span>
}

//mod10 calculate Mod10 DV from string
func mod10(valueSequence string) int <span class="cov0" title="0">{
        sum := 0

        multiplyByTwo := true

        for i := len(valueSequence) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                c := string(valueSequence[i])

                num, _ := strconv.Atoi(c)

                if multiplyByTwo </span><span class="cov0" title="0">{
                        num = num * 2
                        sum += (num / 10) + (num % 10)
                        multiplyByTwo = false
                }</span> else<span class="cov0" title="0"> {
                        sum += num
                        multiplyByTwo = true
                }</span>
        }

        <span class="cov0" title="0">remainder := sum % 10

        if remainder == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return 10 - remainder</span>
}

//OurNumberDv calculate DV from OurNumber
func OurNumberDv(valueSequence string, modFunc ModFunc, base ...int) string <span class="cov0" title="0">{
        digit := 0

        if modFunc == MOD10 </span><span class="cov0" title="0">{
                digit = mod10(valueSequence)
        }</span> else<span class="cov0" title="0"> if modFunc == MOD11 &amp;&amp; base != nil </span><span class="cov0" title="0">{
                digit = mod11(valueSequence, base[0])
        }</span> else<span class="cov0" title="0"> if modFunc == MOD11 </span><span class="cov0" title="0">{
                digit = mod11(valueSequence)
        }</span>

        <span class="cov0" title="0">if base != nil &amp;&amp; digit == 10 </span><span class="cov0" title="0">{
                return "P"
        }</span> else<span class="cov0" title="0"> if digit &gt; 9 </span><span class="cov0" title="0">{
                digit = 0
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(digit)</span>
}

//BarcodeDv calculate DV from barcode
func BarcodeDv(valueSequence string) string <span class="cov0" title="0">{
        digit := mod11(valueSequence)
        if digit &lt;= 1 || digit &gt; 9 </span><span class="cov0" title="0">{
                digit = 1
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(digit)</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package util

import (
        "fmt"
        "strconv"
        "unicode"

        "encoding/json"

        "golang.org/x/text/transform"
        "golang.org/x/text/unicode/norm"
)

func isMn(r rune) bool <span class="cov8" title="1">{
        return unicode.Is(unicode.Mn, r) // Mn: nonspacing marks
}</span>

//RemoveDiacritics remove caracteres especiais de uma string
func RemoveDiacritics(s string) string <span class="cov8" title="1">{
        t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.NFC)
        result, _, _ := transform.String(t, s)
        return result
}</span>

// PadLeft insere um caractere a esquerda de um texto
func PadLeft(value, char string, total uint) string <span class="cov8" title="1">{
        s := "%" + char + strconv.Itoa(int(total)) + "s"
        return fmt.Sprintf(s, value)
}</span>

//Stringify convete objeto para JSON
func Stringify(o interface{}) string <span class="cov0" title="0">{
        b, _ := json.Marshal(o)
        return string(b)
}</span>

//ParseJSON converte string para um objeto GO
func ParseJSON(s string, o interface{}) interface{} <span class="cov0" title="0">{
        json.Unmarshal([]byte(s), o)
        return o
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package util

import (
        "strconv"
        "time"

        "github.com/mundipagg/boleto-api/log"
)

func Duration(callback func()) (duration time.Duration) <span class="cov0" title="0">{
        start := time.Now()
        callback()
        end := time.Now()
        duration = end.Sub(start)
        return
}</span>

func BrNow() time.Time <span class="cov0" title="0">{
        z, err := time.LoadLocation("America/Sao_Paulo")
        if err != nil </span><span class="cov0" title="0">{
                lg := log.CreateLog()
                lg.Warn(err.Error(), "Could not get Timezone")
                return time.Now()
        }</span>
        <span class="cov0" title="0">t := time.Now()
        local := t.In(z)
        return local</span>
}

func NycNow() time.Time <span class="cov0" title="0">{
        z, err := time.LoadLocation("America/New_York")
        if err != nil </span><span class="cov0" title="0">{
                lg := log.CreateLog()
                lg.Warn(err.Error(), "Could not get Timezone")
                return time.Now()
        }</span>
        <span class="cov0" title="0">t := time.Now()
        local := t.In(z)
        return local</span>
}

func GetDurationTimeoutRequest(t string) time.Duration <span class="cov0" title="0">{
        tTime, _ := strconv.Atoi(t)
        tOut := time.Duration(tTime)
        return tOut
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package util

import "crypto/tls"

func GetTLSVersion(version string) uint16 <span class="cov8" title="1">{
        switch version </span>{
        case "1.0":<span class="cov8" title="1">
                return tls.VersionTLS10</span>
        case "1.1":<span class="cov8" title="1">
                return tls.VersionTLS11</span>
        case "1.2":<span class="cov8" title="1">
                return tls.VersionTLS12</span>
        case "1.3":<span class="cov8" title="1">
                return tls.VersionTLS13</span>
        default:<span class="cov8" title="1">
                return tls.VersionTLS12</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
